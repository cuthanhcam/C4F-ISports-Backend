using Microsoft.EntityFrameworkCore;
using api.Interfaces;
using api.Dtos.Field;
using api.Dtos;
using api.Models;
using System.Security.Claims;
using System.Linq;
using api.Data;

namespace api.Services
{
    public class FieldService : IFieldService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IConfiguration _configuration;
        private readonly ILogger<FieldService> _logger;
        private readonly CloudinaryService _cloudinaryService;

        public FieldService(
            IUnitOfWork unitOfWork,
            IConfiguration configuration,
            ILogger<FieldService> logger,
            CloudinaryService cloudinaryService)
        {
            _unitOfWork = unitOfWork;
            _configuration = configuration;
            _logger = logger;
            _cloudinaryService = cloudinaryService;
        }

        public async Task<PaginatedResponse<FieldDto>> GetFieldsAsync(FieldFilterDto filter)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.Services)
                .Include(f => f.FieldDescriptions)
                .AsQueryable();

            if (!string.IsNullOrEmpty(filter.Status))
                query = query.Where(f => f.Status == filter.Status);

            if (filter.SportId.HasValue)
                query = query.Where(f => f.SportId == filter.SportId.Value);

            if (!string.IsNullOrEmpty(filter.Location))
                query = query.Where(f => f.Address.Contains(filter.Location));

            if (filter.MinPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour >= filter.MinPrice.Value));

            if (filter.MaxPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour <= filter.MaxPrice.Value));

            if (!string.IsNullOrEmpty(filter.Sort))
            {
                var sortParts = filter.Sort.Split(':');
                if (sortParts.Length == 2)
                {
                    var sortField = sortParts[0].ToLower();
                    var sortOrder = sortParts[1].ToLower();
                    query = sortField switch
                    {
                        "fieldname" => sortOrder == "asc" ? query.OrderBy(f => f.FieldName) : query.OrderByDescending(f => f.FieldName),
                        "location" => sortOrder == "asc" ? query.OrderBy(f => f.Address) : query.OrderByDescending(f => f.Address),
                        "rating" => sortOrder == "asc" ? query.OrderBy(f => f.Reviews.Average(r => r.Rating)) : query.OrderByDescending(f => f.Reviews.Average(r => r.Rating)),
                        "price" => sortOrder == "asc" ? query.OrderBy(f => f.SubFields.Min(sf => sf.PricePerHour)) : query.OrderByDescending(f => f.SubFields.Max(sf => sf.PricePerHour)),
                        _ => query.OrderBy(f => f.FieldName)
                    };
                }
            }
            else
            {
                query = query.OrderBy(f => f.FieldName);
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((filter.Page - 1) * filter.PageSize)
                .Take(filter.PageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = filter.Page,
                PageSize = filter.PageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<FieldDto> GetFieldByIdAsync(int id)
        {
            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.Services)
                .Include(f => f.FieldDescriptions)
                .FirstOrDefaultAsync(f => f.FieldId == id);

            return field != null ? MapToFieldDto(field) : null;
        }

        public async Task<FieldDto> CreateFieldAsync(ClaimsPrincipal user, CreateFieldDto createFieldDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (owner == null)
                throw new InvalidOperationException($"No Owner found for AccountId {accountId}");

            var field = new Field
            {
                FieldName = createFieldDto.FieldName,
                Address = createFieldDto.Address,
                Phone = createFieldDto.Phone,
                OpenHours = createFieldDto.OpenHours,
                Status = createFieldDto.Status,
                SportId = createFieldDto.SportId,
                Latitude = createFieldDto.Latitude,
                Longitude = createFieldDto.Longitude,
                OwnerId = owner.OwnerId,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            await _unitOfWork.Fields.AddAsync(field);
            await _unitOfWork.SaveChangesAsync();

            if (!string.IsNullOrEmpty(createFieldDto.Description))
            {
                field.FieldDescriptions.Add(new FieldDescription
                {
                    FieldId = field.FieldId,
                    Description = createFieldDto.Description
                });
            }

            if (createFieldDto.Amenities != null && createFieldDto.Amenities.Any())
            {
                foreach (var amenityName in createFieldDto.Amenities)
                {
                    field.FieldAmenities.Add(new FieldAmenity
                    {
                        FieldId = field.FieldId,
                        AmenityName = amenityName
                    });
                }
            }

            if (createFieldDto.Services != null)
            {
                foreach (var service in createFieldDto.Services)
                {
                    field.Services.Add(new Service
                    {
                        FieldId = field.FieldId,
                        ServiceName = service.ServiceName,
                        Price = service.Price
                    });
                }
            }

            if (createFieldDto.SubFields != null && createFieldDto.SubFields.Any())
            {
                foreach (var subFieldDto in createFieldDto.SubFields)
                {
                    var subField = new SubField
                    {
                        FieldId = field.FieldId,
                        SubFieldName = subFieldDto.SubFieldName,
                        Size = subFieldDto.Size,
                        PricePerHour = subFieldDto.PricePerHour
                    };
                    field.SubFields.Add(subField);
                }
            }

            await _unitOfWork.SaveChangesAsync();
            return await GetFieldByIdAsync(field.FieldId);
        }

        public async Task<FieldDto> UpdateFieldAsync(ClaimsPrincipal user, int id, UpdateFieldDto updateFieldDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.FieldAmenities)
                .Include(f => f.Services)
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.SubFieldPricings)
                .Include(f => f.FieldDescriptions)
                .FirstOrDefaultAsync(f => f.FieldId == id);

            if (field == null)
                return null;

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (field.OwnerId != owner.OwnerId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            field.FieldName = updateFieldDto.FieldName;
            field.Address = updateFieldDto.Address;
            field.Phone = updateFieldDto.Phone;
            field.OpenHours = updateFieldDto.OpenHours;
            field.Status = updateFieldDto.Status;
            field.Latitude = updateFieldDto.Latitude;
            field.Longitude = updateFieldDto.Longitude;
            field.UpdatedAt = DateTime.UtcNow;

            field.FieldDescriptions.Clear();
            if (!string.IsNullOrEmpty(updateFieldDto.Description))
            {
                field.FieldDescriptions.Add(new FieldDescription
                {
                    FieldId = field.FieldId,
                    Description = updateFieldDto.Description
                });
            }

            field.FieldAmenities.Clear();
            if (updateFieldDto.AmenityIds != null && updateFieldDto.AmenityIds.Any())
            {
                foreach (var amenityId in updateFieldDto.AmenityIds)
                {
                    field.FieldAmenities.Add(new FieldAmenity
                    {
                        FieldId = field.FieldId,
                        AmenityName = $"Amenity_{amenityId}" // Có thể cần bảng Amenities riêng
                    });
                }
            }

            field.Services.Clear();
            if (updateFieldDto.Services != null)
            {
                foreach (var service in updateFieldDto.Services)
                {
                    field.Services.Add(new Service
                    {
                        FieldId = field.FieldId,
                        ServiceId = service.ServiceId ?? 0,
                        ServiceName = service.ServiceName,
                        Price = service.Price
                    });
                }
            }

            field.SubFields.Clear();
            if (updateFieldDto.SubFields != null && updateFieldDto.SubFields.Any())
            {
                foreach (var subFieldDto in updateFieldDto.SubFields)
                {
                    var subField = new SubField
                    {
                        FieldId = field.FieldId,
                        SubFieldName = subFieldDto.SubFieldName,
                        Size = subFieldDto.Size,
                        PricePerHour = subFieldDto.PricePerHour
                    };
                    field.SubFields.Add(subField);
                }
            }

            await _unitOfWork.SaveChangesAsync();
            return await GetFieldByIdAsync(id);
        }

        public async Task DeleteFieldAsync(ClaimsPrincipal user, int id)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.Bookings)
                .FirstOrDefaultAsync(f => f.FieldId == id);
            if (field == null)
                return;

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (field.OwnerId != owner.OwnerId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            var hasBookings = field.SubFields.Any(sf => sf.Bookings.Any(b => b.Status != "Canceled" && b.Status != "Completed"));
            if (hasBookings)
                throw new InvalidOperationException("Cannot delete field with active bookings");

            _unitOfWork.Fields.Delete(field);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<string> UploadFieldImageAsync(ClaimsPrincipal user, int fieldId, string imageBase64)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetByIdAsync(fieldId);
            if (field == null)
                throw new ArgumentException("Field not found");

            if (field.OwnerId != accountId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            if (string.IsNullOrEmpty(imageBase64))
                throw new ArgumentException("Image data is empty or null");

            byte[] imageBytes = Convert.FromBase64String(imageBase64);
            using var stream = new MemoryStream(imageBytes);
            var file = new FormFile(stream, 0, imageBytes.Length, "fieldImage", "image.jpg")
            {
                Headers = new HeaderDictionary(),
                ContentType = "image/jpeg"
            };

            var imageUrl = await _cloudinaryService.UploadImageAsync(file);
            if (string.IsNullOrEmpty(imageUrl))
                throw new Exception("Failed to upload image to Cloudinary");

            field.FieldImages.Add(new FieldImage
            {
                FieldId = fieldId,
                ImageUrl = imageUrl
            });

            await _unitOfWork.SaveChangesAsync();
            return imageUrl;
        }

        public async Task<PaginatedResponse<FieldDto>> GetOwnerFieldsAsync(
            ClaimsPrincipal user, string status, string sort, int page, int pageSize)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (owner == null)
                throw new InvalidOperationException($"No Owner found for AccountId {accountId}");

            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.SubFieldPricings)
                .Include(f => f.FieldAmenities)
                .Include(f => f.Services)
                .Include(f => f.FieldDescriptions)
                .Where(f => f.OwnerId == owner.OwnerId)
                .AsQueryable();

            if (!string.IsNullOrEmpty(status))
                query = query.Where(f => f.Status == status);

            query = sort?.ToLower() switch
            {
                "name" => query.OrderBy(f => f.FieldName),
                "status" => query.OrderBy(f => f.Status),
                "created" => query.OrderByDescending(f => f.CreatedAt),
                _ => query.OrderByDescending(f => f.UpdatedAt)
            };

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<List<SubFieldAvailabilityDto>> GetSubFieldAvailabilityAsync(int fieldId, DateTime date)
        {
            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.Bookings)
                .FirstOrDefaultAsync(f => f.FieldId == fieldId);

            if (field == null)
                return null;

            var result = new List<SubFieldAvailabilityDto>();
            var openHours = field.OpenHours.Split('-');
            var startTime = TimeSpan.Parse(openHours[0]);
            var endTime = TimeSpan.Parse(openHours[1]);

            foreach (var subField in field.SubFields)
            {
                var slots = new List<TimeSlotDto>();
                var currentTime = startTime;

                while (currentTime < endTime)
                {
                    var slotEndTime = currentTime.Add(TimeSpan.FromHours(1));
                    var isBooked = subField.Bookings.Any(b => 
                        b.BookingDate.Date == date.Date &&
                        TimeSpan.Parse(b.StartTime) <= currentTime &&
                        TimeSpan.Parse(b.EndTime) > currentTime);

                    slots.Add(new TimeSlotDto
                    {
                        StartTime = currentTime.ToString(@"hh\:mm"),
                        EndTime = slotEndTime.ToString(@"hh\:mm"),
                        Status = isBooked ? "Booked" : "Available"
                    });

                    currentTime = slotEndTime;
                }

                result.Add(new SubFieldAvailabilityDto
                {
                    SubFieldId = subField.SubFieldId,
                    Name = subField.SubFieldName,
                    PricePerHour = subField.PricePerHour,
                    Slots = slots
                });
            }

            return result;
        }

        private static FieldDto MapToFieldDto(Field field)
        {
            return new FieldDto
            {
                FieldId = field.FieldId,
                FieldName = field.FieldName,
                SportId = field.SportId,
                SportName = field.Sport?.SportName,
                Address = field.Address,
                Phone = field.Phone,
                OpenHours = field.OpenHours,
                Latitude = field.Latitude,
                Longitude = field.Longitude,
                Status = field.Status,
                Images = field.FieldImages.Select(i => i.ImageUrl).ToList(),
                Amenities = field.FieldAmenities.Select(a => new FieldAmenityDto
                {
                    Name = a.AmenityName,
                    Description = a.Description
                }).ToList(),
                Services = field.Services.Select(s => new FieldServiceDto
                {
                    Name = s.ServiceName,
                    Price = s.Price,
                    Description = s.Description
                }).ToList(),
                SubFields = field.SubFields.Select(sf => new SubFieldDto
                {
                    SubFieldId = sf.SubFieldId,
                    Name = sf.SubFieldName,
                    Size = sf.Size,
                    PricePerHour = sf.PricePerHour,
                    Status = sf.Status
                }).ToList()
            };
        }


        #region TODO: Uncomment and implement the following methods as needed
        /*
        public async Task<PaginatedResponse<FieldReviewDto>> GetFieldReviewsAsync(
            int fieldId, int? rating, string sort, int page, int pageSize)
        {
            var query = _unitOfWork.Reviews.GetAll()
                .Include(r => r.User)
                .Where(r => r.FieldId == fieldId)
                .AsQueryable();

            if (rating.HasValue)
                query = query.Where(r => r.Rating == rating.Value);

            if (!string.IsNullOrEmpty(sort))
            {
                var sortParts = sort.Split(':');
                if (sortParts.Length == 2)
                {
                    var sortField = sortParts[0].ToLower();
                    var sortOrder = sortParts[1].ToLower();
                    query = sortField switch
                    {
                        "createdat" => sortOrder == "asc" ? query.OrderBy(r => r.CreatedAt) : query.OrderByDescending(r => r.CreatedAt),
                        "rating" => sortOrder == "asc" ? query.OrderBy(r => r.Rating) : query.OrderByDescending(r => r.Rating),
                        _ => query.OrderByDescending(r => r.CreatedAt)
                    };
                }
            }
            else
            {
                query = query.OrderByDescending(r => r.CreatedAt);
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldReviewDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(r => new FieldReviewDto
                {
                    ReviewId = r.ReviewId,
                    UserName = r.User?.FullName,
                    Rating = r.Rating,
                    Comment = r.Comment,
                    CreatedAt = r.CreatedAt
                }).ToList()
            };
        }

        public async Task<PaginatedResponse<FieldDto>> GetNearbyFieldsAsync(
            decimal latitude, decimal longitude, decimal radius, string sort, int page, int pageSize)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.SubFieldPricings)
                .Include(f => f.FieldAmenities)
                .Include(f => f.Services)
                .Include(f => f.FieldDescriptions)
                .Where(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude) <= radius)
                .AsQueryable();

            query = sort?.ToLower() switch
            {
                "distance" => query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude)),
                "rating" => query.OrderByDescending(f => f.Reviews.Average(r => r.Rating)),
                "price" => query.OrderBy(f => f.SubFields.Min(sf => sf.SubFieldPricings.Min(p => p.Price))),
                _ => query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude))
            };

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<PaginatedResponse<FieldDto>> SearchFieldsAsync(FieldSearchDto search)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.SubFieldPricings)
                .Include(f => f.Bookings)
                .Include(f => f.FieldAmenities)
                .Include(f => f.Services)
                .Include(f => f.FieldDescriptions)
                .AsQueryable();

            if (!string.IsNullOrEmpty(search.SearchTerm))
            {
                var searchTermLower = search.SearchTerm.ToLower();
                query = query.Where(f =>
                    f.FieldName.ToLower().Contains(searchTermLower) ||
                    f.FieldDescriptions.Any(d => d.Description != null && d.Description.ToLower().Contains(searchTermLower)) ||
                    f.Address.ToLower().Contains(searchTermLower));
            }

            if (search.SportId.HasValue)
                query = query.Where(f => f.SportId == search.SportId.Value);

            if (search.MinPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.SubFieldPricings.Any(p => p.Price >= search.MinPrice.Value)));

            if (search.MaxPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.SubFieldPricings.Any(p => p.Price <= search.MaxPrice.Value)));

            if (search.Latitude.HasValue && search.Longitude.HasValue && search.Radius.HasValue)
            {
                query = query.Where(f =>
                    CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value) <= search.Radius.Value);
            }
            else if (!string.IsNullOrEmpty(search.Location))
            {
                var locationLower = search.Location.ToLower();
                query = query.Where(f => f.Address.ToLower().Contains(locationLower));
            }

            if (search.Time.HasValue)
            {
                var date = search.Time.Value.Date;
                var time = search.Time.Value.TimeOfDay;
                query = query.Where(f => f.SubFields.Any(sf => sf.SubFieldPricings.Any(p =>
                    p.DayOfWeek == (int)date.DayOfWeek &&
                    p.StartTime <= time && p.EndTime >= time &&
                    !sf.Bookings.Any(b => b.BookingDate.Date == date &&
                                         b.StartTime <= p.EndTime && b.EndTime >= p.StartTime))));
            }

            if (!string.IsNullOrEmpty(search.Sort))
            {
                switch (search.Sort.ToLower())
                {
                    case "rating:asc":
                        query = query.OrderBy(f => f.Reviews.Any() ? f.Reviews.Average(r => r.Rating) : 0);
                        break;
                    case "rating:desc":
                        query = query.OrderByDescending(f => f.Reviews.Any() ? f.Reviews.Average(r => r.Rating) : 0);
                        break;
                    case "price:asc":
                        query = query.OrderBy(f => f.SubFields.Any() ? f.SubFields.Min(sf => sf.SubFieldPricings.Min(p => p.Price)) : 0);
                        break;
                    case "price:desc":
                        query = query.OrderByDescending(f => f.SubFields.Any() ? f.SubFields.Max(sf => sf.SubFieldPricings.Max(p => p.Price)) : decimal.MaxValue);
                        break;
                    case "distance:asc":
                        if (search.Latitude.HasValue && search.Longitude.HasValue)
                            query = query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value));
                        break;
                    case "distance:desc":
                        if (search.Latitude.HasValue && search.Longitude.HasValue)
                            query = query.OrderByDescending(f => CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value));
                        break;
                    default:
                        query = query.OrderBy(f => f.FieldName);
                        break;
                }
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((search.Page - 1) * search.PageSize)
                .Take(search.PageSize)
                .Select(f => MapToFieldDto(f))
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = search.Page,
                PageSize = search.PageSize,
                Items = items
            };
        }

        public async Task ReportFieldAsync(int fieldId, FieldReportDto reportDto)
        {
            var field = await _unitOfWork.Fields.GetByIdAsync(fieldId);
            if (field == null)
                throw new ArgumentException("Field not found");

            _logger.LogInformation("Field {FieldId} reported: {Reason}", fieldId, reportDto.Reason);
            // TODO: Thêm logic lưu báo cáo vào DB nếu cần
        }

        public async Task<PaginatedResponse<FieldDto>> GetSuggestedFieldsAsync(
            decimal? latitude, decimal? longitude, int page, int pageSize)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.SubFieldPricings)
                .Include(f => f.FieldAmenities)
                .Include(f => f.Services)
                .Include(f => f.FieldDescriptions)
                .Where(f => f.Status == "Active")
                .AsQueryable();

            if (latitude.HasValue && longitude.HasValue)
            {
                query = query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude.Value, longitude.Value));
            }
            else
            {
                query = query.OrderByDescending(f => f.Reviews.Average(r => r.Rating));
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        private decimal CalculateDistance(decimal lat1, decimal lon1, decimal lat2, decimal lon2)
        {
            var R = 6371m; // Bán kính trái đất (km)
            var dLat = ToRad(lat2 - lat1);
            var dLon = ToRad(lon2 - lon1);
            var a = (decimal)Math.Sin((double)(dLat / 2)) * (decimal)Math.Sin((double)(dLat / 2)) +
                    (decimal)Math.Cos((double)ToRad(lat1)) * (decimal)Math.Cos((double)ToRad(lat2)) *
                    (decimal)Math.Sin((double)(dLon / 2)) * (decimal)Math.Sin((double)(dLon / 2));
            var c = 2 * (decimal)Math.Atan2(Math.Sqrt((double)a), Math.Sqrt(1 - (double)a));
            return R * c;
        }

        private decimal ToRad(decimal value)
        {
            return value * (decimal)Math.PI / 180;
        }
        */
        #endregion
    }
}

// api/Controllers/FieldController.cs
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using api.Interfaces;
using api.Dtos.Field;
using api.Dtos;
using System.Security.Claims;

namespace api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class FieldController : ControllerBase
    {
        private readonly IFieldService _fieldService;

        public FieldController(IFieldService fieldService)
        {
            _fieldService = fieldService;
        }

        [HttpGet]
        public async Task<ActionResult<PaginatedResponse<FieldDto>>> GetFields([FromQuery] FieldFilterDto filter)
        {
            var fields = await _fieldService.GetFieldsAsync(filter);
            return Ok(fields);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<FieldDto>> GetFieldById(int id)
        {
            var field = await _fieldService.GetFieldByIdAsync(id);
            if (field == null)
                return NotFound("Không tìm thấy sân");
            return Ok(field);
        }

        [HttpGet("{id}/availability")]
        public async Task<ActionResult<List<SubFieldAvailabilityDto>>> GetSubFieldAvailability(int id, [FromQuery] DateTime date)
        {
            var slots = await _fieldService.GetSubFieldAvailabilityAsync(id, date);
            if (slots == null)
                return NotFound("Không tìm thấy sân");
            return Ok(slots);
        }

        [Authorize(Roles = "Owner")]
        [HttpPost]
        public async Task<ActionResult<FieldDto>> CreateField([FromBody] CreateFieldDto createFieldDto)
        {
            var field = await _fieldService.CreateFieldAsync(User, createFieldDto);
            return CreatedAtAction(nameof(GetFieldById), new { id = field.FieldId }, field);
        }

        [Authorize(Roles = "Owner")]
        [HttpPut("{id}")]
        public async Task<ActionResult<FieldDto>> UpdateField(int id, [FromBody] UpdateFieldDto updateFieldDto)
        {
            var field = await _fieldService.UpdateFieldAsync(User, id, updateFieldDto);
            if (field == null)
                return NotFound("Không tìm thấy sân");
            return Ok(field);
        }

        [Authorize(Roles = "Owner")]
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteField(int id)
        {
            await _fieldService.DeleteFieldAsync(User, id);
            return NoContent();
        }

        [Authorize(Roles = "Owner")]
        [HttpPost("{id}/images")]
        public async Task<ActionResult<string>> UploadFieldImage(int id, [FromBody] string imageBase64)
        {
            var imageUrl = await _fieldService.UploadFieldImageAsync(User, id, imageBase64);
            return Ok(new { imageUrl });
        }

        [Authorize(Roles = "Owner")]
        [HttpGet("owner")]
        public async Task<ActionResult<PaginatedResponse<FieldDto>>> GetOwnerFields(
            [FromQuery] string status,
            [FromQuery] string sort,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 10)
        {
            var fields = await _fieldService.GetOwnerFieldsAsync(User, status, sort, page, pageSize);
            return Ok(fields);
        }

        #region Search and Filter
        /*
        [HttpGet("search")]
        public async Task<ActionResult<PaginatedResponse<FieldDto>>> SearchFields([FromQuery] FieldSearchDto search)
        {
            var fields = await _fieldService.SearchFieldsAsync(search);
            return Ok(fields);
        }

        [HttpGet("{id}/reviews")]
        public async Task<ActionResult<PaginatedResponse<FieldReviewDto>>> GetFieldReviews(
            int id, [FromQuery] int? rating, [FromQuery] string sort, [FromQuery] int page = 1, [FromQuery] int pageSize = 10)
        {
            var reviews = await _fieldService.GetFieldReviewsAsync(id, rating, sort, page, pageSize);
            return Ok(reviews);
        }

        [HttpGet("nearby")]
        public async Task<ActionResult<PaginatedResponse<FieldDto>>> GetNearbyFields(
            [FromQuery] decimal latitude, [FromQuery] decimal longitude, [FromQuery] decimal radius,
            [FromQuery] string sort, [FromQuery] int page = 1, [FromQuery] int pageSize = 10)
        {
            var fields = await _fieldService.GetNearbyFieldsAsync(latitude, longitude, radius, sort, page, pageSize);
            return Ok(fields);
        }

        [Authorize(Roles = "User")]
        [HttpPost("{fieldId}/report")]
        public async Task<ActionResult> ReportField(int fieldId, [FromBody] FieldReportDto reportDto)
        {
            await _fieldService.ReportFieldAsync(fieldId, reportDto);
            return NoContent();
        }

        [HttpGet("suggested")]
        public async Task<ActionResult<PaginatedResponse<FieldDto>>> GetSuggestedFields(
            [FromQuery] decimal? latitude,
            [FromQuery] decimal? longitude,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 10)
        {
            var fields = await _fieldService.GetSuggestedFieldsAsync(latitude, longitude, page, pageSize);
            return Ok(fields);
        }
        */
        #endregion
    }
}

// Models
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace api.Models
{
    public class Field
    {
        public int FieldId { get; set; } // Mã sân (PK)
        public int SportId { get; set; } // Liên kết với bảng Sports (FK)
        public string FieldName { get; set; } // Tên sân
        public string Phone { get; set; } // Số điện thoại đặt lịch
        public string Address { get; set; } // Địa chỉ sân
        public string OpenHours { get; set; } // Khung giờ mở cửa (VD: 8:00 - 22:00)
        public int OwnerId { get; set; } // Liên kết với bảng Owners (FK)
        public string Status { get; set; } // Trạng thái sân (Active, Inactive, Maintenance)
        public decimal Latitude { get; set; } // Vĩ độ GPS
        public decimal Longitude { get; set; } // Kinh độ GPS
        public DateTime CreatedAt { get; set; } // Ngày tạo sân
        public DateTime UpdatedAt { get; set; } // Ngày cập nhật sân

        // Các thuộc tính điều hướng (Navigation Properties)
        public Sport Sport { get; set; }
        public Owner Owner { get; set; }
        public ICollection<Booking> Bookings { get; set; } = new List<Booking>();
        public ICollection<Review> Reviews { get; set; } = new List<Review>();
        public ICollection<FieldImage> FieldImages { get; set; } = new List<FieldImage>();
        public ICollection<SubField> SubFields { get; set; } = new List<SubField>();
        public ICollection<FieldAmenity> FieldAmenities { get; set; } = new List<FieldAmenity>();
        public ICollection<FieldDescription> FieldDescriptions { get; set; } = new List<FieldDescription>();
        public ICollection<Service> Services { get; set; } = new List<Service>();
        public ICollection<FavoriteField> FavoriteFields { get; set; } = new List<FavoriteField>();
    }
}

    public class SubField
    {
        public int SubFieldId { get; set; } // Mã sân nhỏ (PK)
        public int FieldId { get; set; } // Liên kết với sân lớn (FK)
        public string SubFieldName { get; set; } // Tên sân nhỏ (ví dụ: "Sân 5-1", "Sân 7-2")
        public int Size { get; set; } // Kích thước (5 người, 7 người, 11 người, v.v.)
        public decimal PricePerHour { get; set; } // Giá mỗi giờ

        public Field Field { get; set; } // Quan hệ với bảng Field
        public ICollection<Booking> Bookings { get; set; } = new List<Booking>(); // Đặt sân riêng
    }

        public class FieldAmenity
    {
        public int FieldAmenityId { get; set; }
        public int FieldId { get; set; }
        public string AmenityName { get; set; } // Tên tiện ích (vd: Wifi, Điều hòa, Nước uống,...)

        public Field Field { get; set; }
    }

        public class Service
    {
        public int ServiceId { get; set; }
        public int FieldId { get; set; }
        public string ServiceName { get; set; } // Tên dịch vụ (vd: Nước uống, Đồ ăn nhẹ,...)
        public decimal Price { get; set; } // Giá dịch vụ (vd: 20000 cho nước uống, 50000 cho đồ ăn nhẹ,...)

        public Field Field { get; set; }
        public ICollection<BookingService> BookingServices { get; set; } // Thêm quan hệ 1-n
    }

        public class FieldImage
    {
        public int FieldImageId { get; set; }
        public int FieldId { get; set; }
        public string? Thumbnail { get; set; } // Ảnh Thumbnail (nếu có)
        public string ImageUrl { get; set; } // URL Cloudinary
        
        public Field Field { get; set; }
    }

    public class Booking
    {
        public int BookingId { get; set; } // Mã đặt sân (PK)
        public int UserId { get; set; } // Người đặt (FK)
        public int FieldId { get; set; } // Sân được đặt (FK)
        public DateTime BookingDate { get; set; } // Ngày đặt sân
        public TimeSpan StartTime { get; set; } // Giờ bắt đầu
        public TimeSpan EndTime { get; set; } // Giờ kết thúc
        public decimal TotalPrice { get; set; } // Tổng tiền
        public string Status { get; set; } // Trạng thái (Pending, Confirmed, Canceled, Completed)
        public string PaymentStatus { get; set; } // Trạng thái thanh toán (Unpaid, Partially Paid, Paid)
        public DateTime CreatedAt { get; set; } // Ngày tạo đơn
        public DateTime UpdatedAt { get; set; } // Ngày cập nhật đơn

        public User User { get; set; } // Quan hệ với bảng User
        public SubField SubField { get; set; } // Quan hệ với bảng SubField
    }

    
