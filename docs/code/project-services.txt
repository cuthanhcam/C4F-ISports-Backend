using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using api.Data;
using api.Dtos.Auth;
using api.Interfaces;
using api.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;

namespace api.Services
{
    public class AuthService : IAuthService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IConfiguration _configuration;
        private readonly IEmailSender _emailSender;

        public AuthService(IUnitOfWork unitOfWork, IConfiguration configuration, IEmailSender emailSender)
        {
            _unitOfWork = unitOfWork;
            _configuration = configuration;
            _emailSender = emailSender;
        }

        public async Task<(string Token, string RefreshToken)> RegisterAsync(RegisterDto registerDto)
        {
            if (registerDto.Role == "Admin")
            {
                throw new Exception("Không thể đăng ký tài khoản với vai trò Admin.");
            }

            if (_unitOfWork.Accounts.GetAll().Any(a => a.Email == registerDto.Email))
            {
                throw new Exception("Email đã tồn tại.");
            }

            var account = new Account
            {
                Email = registerDto.Email,
                Password = BCrypt.Net.BCrypt.HashPassword(registerDto.Password),
                Role = registerDto.Role,
                IsActive = false,
                CreatedAt = DateTime.UtcNow,
                VerificationToken = Guid.NewGuid().ToString(),
                VerificationTokenExpiry = DateTime.UtcNow.AddHours(24)
            };

            await _unitOfWork.Accounts.AddAsync(account);
            await _unitOfWork.SaveChangesAsync();

            if (registerDto.Role == "User")
            {
                var user = new User
                {
                    AccountId = account.AccountId,
                    FullName = registerDto.FullName,
                    Email = registerDto.Email,
                    Phone = registerDto.Phone,
                    DateOfBirth = null,
                    Gender = "Unknown"
                };
                await _unitOfWork.Users.AddAsync(user);
            }
            else if (registerDto.Role == "Owner")
            {
                var owner = new Owner
                {
                    AccountId = account.AccountId,
                    FullName = registerDto.FullName,
                    Email = registerDto.Email,
                    Phone = registerDto.Phone,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };
                await _unitOfWork.Owners.AddAsync(owner);
            }

            await _unitOfWork.SaveChangesAsync();

            // Gửi email xác thực
            var verificationLink = $"{_configuration["AppUrl"]}/api/auth/verify-email?email={account.Email}&token={account.VerificationToken}";
            var emailSubject = "Xác thực tài khoản C4F ISports";
            var emailBody = $"<h3>Xin chào {registerDto.FullName},</h3>" +
                            $"<p>Vui lòng nhấp vào liên kết sau để xác thực email của bạn:</p>" +
                            $"<a href='{verificationLink}'>Xác thực ngay</a>" +
                            $"<p>Liên kết này có hiệu lực trong 24 giờ.</p>" +
                            $"<p>Trân trọng,<br/>Đội ngũ C4F ISports</p>";
            await _emailSender.SendEmailAsync(account.Email, emailSubject, emailBody);

            var token = GenerateJwtToken(account);
            var refreshToken = await GenerateRefreshTokenAsync(account);
            return (token, refreshToken.Token);
        }

        public async Task<(string Token, string RefreshToken)> LoginAsync(LoginDto loginDto)
        {
            var account = await _unitOfWork.Accounts.GetAll()
                .Include(a => a.User)
                .Include(a => a.Owner)
                .FirstOrDefaultAsync(a => a.Email == loginDto.Email);

            if (account == null || !BCrypt.Net.BCrypt.Verify(loginDto.Password, account.Password))
            {
                throw new Exception("Email hoặc mật khẩu không chính xác.");
            }

            if (!account.IsActive)
            {
                throw new Exception("Tài khoản chưa được xác thực. Vui lòng kiểm tra email của bạn.");
            }

            account.LastLogin = DateTime.UtcNow;
            await _unitOfWork.SaveChangesAsync();

            var token = GenerateJwtToken(account);
            var refreshToken = await GenerateRefreshTokenAsync(account);
            return (token, refreshToken.Token);
        }

        public async Task<(string Token, string RefreshToken)> RefreshTokenAsync(string refreshToken)
        {
            var token = _unitOfWork.RefreshTokens.GetAll()
                .FirstOrDefault(t => t.Token == refreshToken && t.Expires > DateTime.UtcNow && !t.Revoked.HasValue);

            if (token == null)
            {
                throw new Exception("Invalid or expired refresh token.");
            }

            var account = await _unitOfWork.Accounts.GetByIdAsync(token.AccountId);
            if (account == null)
            {
                throw new Exception("Account not found.");
            }

            var newToken = GenerateJwtToken(account);
            var newRefreshToken = await GenerateRefreshTokenAsync(account);
            token.Revoked = DateTime.UtcNow;
            token.ReplacedByToken = newRefreshToken.Token;
            _unitOfWork.RefreshTokens.Update(token);
            await _unitOfWork.SaveChangesAsync();

            return (newToken, newRefreshToken.Token);
        }

        public async Task ForgotPasswordAsync(string email)
        {
            var account = _unitOfWork.Accounts.GetAll().FirstOrDefault(a => a.Email == email);

            if (account == null)
            {
                throw new Exception("Email not found.");
            }

            var resetToken = Guid.NewGuid().ToString();
            account.ResetToken = resetToken;
            account.ResetTokenExpiry = DateTime.UtcNow.AddHours(1);
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();

            // Gửi email reset password
            var resetLink = $"{_configuration["FEUrl"]}/auth/reset-password?email={account.Email}&token={resetToken}";
            var emailSubject = "Đặt lại mật khẩu C4F ISports";
            var emailBody = $"<h3>Xin chào {account.Email},</h3>" +
                            $"<p>Bạn đã yêu cầu đặt lại mật khẩu. Nhấp vào liên kết sau để tiếp tục:</p>" +
                            $"<a href='{resetLink}'>Đặt lại mật khẩu</a>" +
                            $"<p>Liên kết này có hiệu lực trong 1 giờ.</p>" +
                            $"<p>Trân trọng,<br/>Đội ngũ C4F ISports</p>";
            await _emailSender.SendEmailAsync(account.Email, emailSubject, emailBody);
        }

        public async Task ResetPasswordAsync(ResetPasswordDto resetPasswordDto)
        {
            var account = _unitOfWork.Accounts.GetAll()
                .FirstOrDefault(a => a.Email == resetPasswordDto.Email && a.ResetToken == resetPasswordDto.Token);

            if (account == null || account.ResetTokenExpiry < DateTime.UtcNow)
            {
                throw new Exception("Invalid or expired reset token.");
            }

            account.Password = BCrypt.Net.BCrypt.HashPassword(resetPasswordDto.NewPassword);
            account.ResetToken = null;
            account.ResetTokenExpiry = null;
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task LogoutAsync(string refreshToken)
        {
            var token = _unitOfWork.RefreshTokens.GetAll().FirstOrDefault(t => t.Token == refreshToken);
            if (token != null)
            {
                token.Revoked = DateTime.UtcNow;
                _unitOfWork.RefreshTokens.Update(token);
                await _unitOfWork.SaveChangesAsync();
            }
        }

        public async Task<bool> VerifyTokenAsync(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_configuration["JwtSettings:Secret"]);
            try
            {
                tokenHandler.ValidateToken(token, new TokenValidationParameters
                {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ValidateLifetime = true
                }, out _);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<bool> VerifyEmailAsync(string email, string token)
        {
            var account = _unitOfWork.Accounts.GetAll()
                .FirstOrDefault(a => a.Email == email && a.VerificationToken == token);

            if (account == null || account.VerificationTokenExpiry < DateTime.UtcNow)
            {
                throw new Exception("Invalid or expired verification token.");
            }

            if (account.IsActive)
            {
                throw new Exception("Email already verified.");
            }

            account.IsActive = true;
            account.VerificationToken = null;
            account.VerificationTokenExpiry = null;
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();

            return true;
        }

        public async Task ResendVerificationEmailAsync(string email)
        {
            var account = await _unitOfWork.Accounts.GetAll()
                .FirstOrDefaultAsync(a => a.Email == email);

            if (account == null)
            {
                throw new Exception("Email không tồn tại trong hệ thống.");
            }

            if (account.IsActive)
            {
                throw new Exception("Tài khoản đã được kích hoạt, không cần gửi lại email xác thực.");
            }

            // Tạo mới VerificationToken
            account.VerificationToken = Guid.NewGuid().ToString();
            account.VerificationTokenExpiry = DateTime.UtcNow.AddHours(24); // Token có hiệu lực 24 giờ
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();

            // Gửi email xác thực
            var verificationLink = $"{_configuration["AppUrl"]}/api/auth/verify-email?email={account.Email}&token={account.VerificationToken}";
            var emailSubject = "Xác thực lại tài khoản C4F ISports";
            var emailBody = $"<h3>Xin chào {account.Email},</h3>" +
                            $"<p>Bạn đã yêu cầu gửi lại email xác thực. Vui lòng nhấp vào liên kết sau để xác thực tài khoản:</p>" +
                            $"<a href='{verificationLink}'>Xác thực ngay</a>" +
                            $"<p>Liên kết này có hiệu lực trong 24 giờ.</p>" +
                            $"<p>Trân trọng,<br/>Đội ngũ C4F ISports</p>";
            await _emailSender.SendEmailAsync(account.Email, emailSubject, emailBody);
        }

        private string GenerateJwtToken(Account account)
        {
            var claims = new[]
            {
                new Claim(ClaimTypes.NameIdentifier, account.AccountId.ToString()),
                new Claim(ClaimTypes.Email, account.Email),
                new Claim(ClaimTypes.Role, account.Role)
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["JwtSettings:Secret"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var token = new JwtSecurityToken(
                claims: claims,
                expires: DateTime.UtcNow.AddMinutes(int.Parse(_configuration["JwtSettings:TokenExpiryMinutes"])),
                signingCredentials: creds);

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        private async Task<RefreshToken> GenerateRefreshTokenAsync(Account account)
        {
            var refreshToken = new RefreshToken
            {
                AccountId = account.AccountId,
                Token = Guid.NewGuid().ToString(),
                Expires = DateTime.UtcNow.AddDays(int.Parse(_configuration["JwtSettings:RefreshTokenExpiryDays"])),
                Created = DateTime.UtcNow
            };
            await _unitOfWork.RefreshTokens.AddAsync(refreshToken);
            await _unitOfWork.SaveChangesAsync();
            return refreshToken;
        }

        public async Task<Account> GetCurrentUserAsync(ClaimsPrincipal user)
        {
            var accountIdClaim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(accountIdClaim) || !int.TryParse(accountIdClaim, out int accountId))
            {
                throw new Exception("Invalid user token.");
            }

            var account = await _unitOfWork.Accounts.GetAll()
                .Include(a => a.User)
                .Include(a => a.Owner)
                .FirstOrDefaultAsync(a => a.AccountId == accountId);
            if (account == null)
            {
                throw new Exception("User not found.");
            }

            return account;
        }

        public async Task ChangePasswordAsync(ClaimsPrincipal user, ChangePasswordDto changePasswordDto)
        {
            var account = await GetCurrentUserAsync(user);

            if (!BCrypt.Net.BCrypt.Verify(changePasswordDto.OldPassword, account.Password))
            {
                throw new Exception("Old password is incorrect.");
            }

            account.Password = BCrypt.Net.BCrypt.HashPassword(changePasswordDto.NewPassword);
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();
        }
    }
}
using api.Interfaces;
using CloudinaryDotNet;
using CloudinaryDotNet.Actions;
using Microsoft.Extensions.Configuration;
using System.Threading.Tasks;

namespace api.Services
{
    public class CloudinaryService : ICloudinaryService
    {
        private readonly Cloudinary _cloudinary;

        public CloudinaryService(IConfiguration configuration)
        {
            var cloudinarySettings = configuration.GetSection("CloudinarySettings");
            var account = new Account(
                cloudinarySettings["CloudName"],
                cloudinarySettings["ApiKey"],
                cloudinarySettings["ApiSecret"]
            );
            _cloudinary = new Cloudinary(account);
        }

        // Upload hình ảnh từ IFormFile
        public async Task<string> UploadImageAsync(IFormFile file)
        {
            if (file == null || file.Length == 0)
                throw new ArgumentException("File is empty or null.");

            var uploadParams = new ImageUploadParams
            {
                File = new FileDescription(file.FileName, file.OpenReadStream()),
                Transformation = new Transformation().Width(800).Height(800).Crop("limit") // Tùy chỉnh kích thước
            };

            var uploadResult = await _cloudinary.UploadAsync(uploadParams);
            return uploadResult.SecureUrl.ToString(); // Trả về URL an toàn
        }

        // Xóa hình ảnh theo publicId
        public async Task<bool> DeleteImageAsync(string publicId)
        {
            var deletionParams = new DeletionParams(publicId);
            var result = await _cloudinary.DestroyAsync(deletionParams);
            return result.Result == "ok";
        }
    }
}
using Microsoft.EntityFrameworkCore;
using api.Interfaces;
using api.Dtos.Field;
using api.Dtos;
using api.Models;
using System.Security.Claims;
using System.Linq;
using api.Data;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using api.Exceptions;

namespace api.Services
{
    public class FieldService : IFieldService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IConfiguration _configuration;
        private readonly ILogger<FieldService> _logger;
        private readonly CloudinaryService _cloudinaryService;
        private readonly IGeocodingService _geocodingService;

        public FieldService(
            IUnitOfWork unitOfWork,
            IConfiguration configuration,
            ILogger<FieldService> logger,
            CloudinaryService cloudinaryService,
            IGeocodingService geocodingService)
        {
            _unitOfWork = unitOfWork;
            _configuration = configuration;
            _logger = logger;
            _cloudinaryService = cloudinaryService;
            _geocodingService = geocodingService;
        }

        public async Task<PaginatedResponse<FieldDto>> GetFieldsAsync(FieldFilterDto filter)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices) // Đổi từ Services
                .Include(f => f.FieldDescriptions)
                .AsQueryable();

            if (!string.IsNullOrEmpty(filter.Status))
                query = query.Where(f => f.Status == filter.Status);

            if (filter.SportId.HasValue)
                query = query.Where(f => f.SportId == filter.SportId.Value);

            if (!string.IsNullOrEmpty(filter.Location))
                query = query.Where(f => f.Address.Contains(filter.Location));

            if (filter.MinPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour >= filter.MinPrice.Value));

            if (filter.MaxPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour <= filter.MaxPrice.Value));

            if (!string.IsNullOrEmpty(filter.Sort))
            {
                var sortParts = filter.Sort.Split(':');
                if (sortParts.Length == 2)
                {
                    var sortField = sortParts[0].ToLower();
                    var sortOrder = sortParts[1].ToLower();
                    query = sortField switch
                    {
                        "fieldname" => sortOrder == "asc" ? query.OrderBy(f => f.FieldName) : query.OrderByDescending(f => f.FieldName),
                        "location" => sortOrder == "asc" ? query.OrderBy(f => f.Address) : query.OrderByDescending(f => f.Address),
                        "rating" => sortOrder == "asc" ? query.OrderBy(f => f.Reviews.Average(r => r.Rating)) : query.OrderByDescending(f => f.Reviews.Average(r => r.Rating)),
                        "price" => sortOrder == "asc" ? query.OrderBy(f => f.SubFields.Min(sf => sf.PricePerHour)) : query.OrderByDescending(f => f.SubFields.Min(sf => sf.PricePerHour)),
                        _ => query.OrderBy(f => f.FieldName)
                    };
                }
            }
            else
            {
                query = query.OrderBy(f => f.FieldName);
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((filter.Page - 1) * filter.PageSize)
                .Take(filter.PageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = filter.Page,
                PageSize = filter.PageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<FieldDto> GetFieldByIdAsync(int id)
        {
            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .FirstOrDefaultAsync(f => f.FieldId == id);

            return field != null ? MapToFieldDto(field) : null;
        }

        public async Task<FieldDto> CreateFieldAsync(ClaimsPrincipal user, CreateFieldDto createFieldDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (owner == null)
                throw new ResourceNotFoundException($"No Owner found for AccountId {accountId}");

            var normalizedAddress = NormalizeAddress(createFieldDto.Address);
            decimal latitude = 0m; // Tọa độ mặc định nếu thất bại
            decimal longitude = 0m;
            try
            {
                (latitude, longitude) = await _geocodingService.GetCoordinatesFromAddressAsync(normalizedAddress);
                if (Math.Abs(latitude) > 90 || Math.Abs(longitude) > 180)
                    throw new AppException("Tọa độ không hợp lệ từ dịch vụ địa chỉ");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Geocoding failed for address: {Address}. Using default coordinates (0,0)", normalizedAddress);
                latitude = 0m; // Fallback tọa độ
                longitude = 0m;
                // Không ném exception để tiếp tục tạo field
            }

            var field = new Field
            {
                FieldName = createFieldDto.FieldName,
                Address = createFieldDto.Address,
                Phone = createFieldDto.Phone,
                OpenHours = createFieldDto.OpenHours,
                Status = createFieldDto.Status,
                SportId = createFieldDto.SportId,
                Latitude = latitude,
                Longitude = longitude,
                OwnerId = owner.OwnerId,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            await _unitOfWork.Fields.AddAsync(field);
            await _unitOfWork.SaveChangesAsync();

            // Logic thêm description, amenities, services, subfields giữ nguyên
            if (!string.IsNullOrEmpty(createFieldDto.Description))
            {
                field.FieldDescriptions.Add(new FieldDescription
                {
                    FieldId = field.FieldId,
                    Description = createFieldDto.Description
                });
            }

            if (createFieldDto.Amenities != null && createFieldDto.Amenities.Any())
            {
                foreach (var amenity in createFieldDto.Amenities)
                {
                    field.FieldAmenities.Add(new FieldAmenity
                    {
                        FieldId = field.FieldId,
                        AmenityName = amenity.Name,
                        Description = amenity.Description ?? string.Empty
                    });
                }
            }

            if (createFieldDto.Services != null && createFieldDto.Services.Any())
            {
                foreach (var service in createFieldDto.Services)
                {
                    field.FieldServices.Add(new Models.FieldService
                    {
                        FieldId = field.FieldId,
                        ServiceName = service.ServiceName,
                        Price = service.Price,
                        Description = service.Description ?? string.Empty
                    });
                }
            }

            if (createFieldDto.SubFields != null && createFieldDto.SubFields.Any())
            {
                foreach (var subFieldDto in createFieldDto.SubFields)
                {
                    field.SubFields.Add(new SubField
                    {
                        FieldId = field.FieldId,
                        SubFieldName = subFieldDto.SubFieldName,
                        Size = subFieldDto.Size,
                        PricePerHour = subFieldDto.PricePerHour,
                        Status = "Active"
                    });
                }
            }

            await _unitOfWork.SaveChangesAsync();
            return await GetFieldByIdAsync(field.FieldId);
        }

        public async Task<FieldDto> UpdateFieldAsync(ClaimsPrincipal user, int id, UpdateFieldDto updateFieldDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.SubFields)
                .Include(f => f.FieldDescriptions)
                .FirstOrDefaultAsync(f => f.FieldId == id);

            if (field == null)
                throw new ResourceNotFoundException($"Field with ID {id} not found");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (field.OwnerId != owner?.OwnerId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            var normalizedAddress = NormalizeAddress(updateFieldDto.Address);
            decimal latitude = 0m; // Tọa độ mặc định nếu thất bại
            decimal longitude = 0m;
            try
            {
                (latitude, longitude) = await _geocodingService.GetCoordinatesFromAddressAsync(normalizedAddress);
                if (Math.Abs(latitude) > 90 || Math.Abs(longitude) > 180)
                    throw new AppException("Tọa độ không hợp lệ từ dịch vụ địa chỉ");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Geocoding failed for address: {Address}. Using default coordinates (0,0)", normalizedAddress);
                latitude = 0m; // Fallback tọa độ
                longitude = 0m;
                // Không ném exception để tiếp tục tạo field
            }

            field.FieldName = updateFieldDto.FieldName;
            field.Address = updateFieldDto.Address;
            field.Phone = updateFieldDto.Phone;
            field.OpenHours = updateFieldDto.OpenHours;
            field.Status = updateFieldDto.Status;
            field.Latitude = latitude;
            field.Longitude = longitude;
            field.UpdatedAt = DateTime.UtcNow;

            // Logic cập nhật description, amenities, services, subfields giữ nguyên
            field.FieldDescriptions.Clear();
            if (!string.IsNullOrEmpty(updateFieldDto.Description))
            {
                field.FieldDescriptions.Add(new FieldDescription
                {
                    FieldId = field.FieldId,
                    Description = updateFieldDto.Description
                });
            }

            field.FieldAmenities.Clear();
            if (updateFieldDto.Amenities != null && updateFieldDto.Amenities.Any())
            {
                foreach (var amenity in updateFieldDto.Amenities)
                {
                    field.FieldAmenities.Add(new FieldAmenity
                    {
                        FieldId = field.FieldId,
                        AmenityName = amenity.Name,
                        Description = amenity.Description ?? string.Empty
                    });
                }
            }

            field.FieldServices.Clear();
            if (updateFieldDto.Services != null && updateFieldDto.Services.Any())
            {
                foreach (var service in updateFieldDto.Services)
                {
                    field.FieldServices.Add(new Models.FieldService
                    {
                        FieldId = field.FieldId,
                        ServiceName = service.ServiceName,
                        Price = service.Price,
                        Description = service.Description ?? string.Empty
                    });
                }
            }

            field.SubFields.Clear();
            if (updateFieldDto.SubFields != null && updateFieldDto.SubFields.Any())
            {
                foreach (var subFieldDto in updateFieldDto.SubFields)
                {
                    field.SubFields.Add(new SubField
                    {
                        FieldId = field.FieldId,
                        SubFieldName = subFieldDto.SubFieldName,
                        Size = subFieldDto.Size,
                        PricePerHour = subFieldDto.PricePerHour,
                        Status = subFieldDto.Status ?? "Active"
                    });
                }
            }

            await _unitOfWork.SaveChangesAsync();
            return await GetFieldByIdAsync(id);
        }

        private string NormalizeAddress(string address)
        {
            if (string.IsNullOrWhiteSpace(address))
            {
                _logger.LogError("Address is null or empty");
                throw new ArgumentException("Địa chỉ không được để trống");
            }

            // Loại bỏ khoảng trắng thừa
            address = address.Trim();

            // Chuẩn hóa dấu phẩy
            address = address.Replace(" ,", ",").Replace(", ", ",");

            // Loại bỏ "Việt Nam" hoặc "Vietnam" ở cuối nếu có
            address = address.TrimEnd(new[] { ',', ' ' });
            if (address.EndsWith(",Việt Nam", StringComparison.OrdinalIgnoreCase) ||
                address.EndsWith(",Vietnam", StringComparison.OrdinalIgnoreCase))
            {
                address = address.Substring(0, address.LastIndexOf(','));
            }

            // Thêm quốc gia nếu chưa có
            if (!address.EndsWith(", Việt Nam", StringComparison.OrdinalIgnoreCase) &&
                !address.EndsWith(", Vietnam", StringComparison.OrdinalIgnoreCase))
            {
                address = $"{address}, Việt Nam";
            }

            _logger.LogDebug("Normalized address from '{Original}' to '{Normalized}'", address, address);
            return address;
        }

        public async Task DeleteFieldAsync(ClaimsPrincipal user, int id)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.Bookings)
                .FirstOrDefaultAsync(f => f.FieldId == id);
            if (field == null)
                return;

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (field.OwnerId != owner.OwnerId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            var hasBookings = field.SubFields.Any(sf => sf.Bookings.Any(b => b.Status != "Canceled" && b.Status != "Completed"));
            if (hasBookings)
                throw new InvalidOperationException("Cannot delete field with active bookings");

            _unitOfWork.Fields.Delete(field);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<string> UploadFieldImageAsync(ClaimsPrincipal user, int fieldId, string imageBase64)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetByIdAsync(fieldId);
            if (field == null)
                throw new ArgumentException("Field not found");

            if (field.OwnerId != accountId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            if (string.IsNullOrEmpty(imageBase64))
                throw new ArgumentException("Image data is empty or null");

            byte[] imageBytes = Convert.FromBase64String(imageBase64);
            using var stream = new MemoryStream(imageBytes);
            var file = new FormFile(stream, 0, imageBytes.Length, "fieldImage", "image.jpg")
            {
                Headers = new HeaderDictionary(),
                ContentType = "image/jpeg"
            };

            var imageUrl = await _cloudinaryService.UploadImageAsync(file);
            if (string.IsNullOrEmpty(imageUrl))
                throw new Exception("Failed to upload image to Cloudinary");

            field.FieldImages.Add(new FieldImage
            {
                FieldId = fieldId,
                ImageUrl = imageUrl
            });

            await _unitOfWork.SaveChangesAsync();
            return imageUrl;
        }

        public async Task<PaginatedResponse<FieldDto>> GetOwnerFieldsAsync(
            ClaimsPrincipal user, string status, string sort, int page, int pageSize)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (owner == null)
                throw new InvalidOperationException($"No Owner found for AccountId {accountId}");

            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .Where(f => f.OwnerId == owner.OwnerId)
                .AsQueryable();

            if (!string.IsNullOrEmpty(status))
                query = query.Where(f => f.Status == status);

            query = sort?.ToLower() switch
            {
                "name" => query.OrderBy(f => f.FieldName),
                "status" => query.OrderBy(f => f.Status),
                "created" => query.OrderByDescending(f => f.CreatedAt),
                _ => query.OrderByDescending(f => f.UpdatedAt)
            };

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<FieldAvailabilityDto> GetFieldAvailabilityAsync(int fieldId, DateTime date)
        {
            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.FieldServices)
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.Bookings)
                .FirstOrDefaultAsync(f => f.FieldId == fieldId);

            if (field == null)
                return null;

            var openHours = field.OpenHours.Split('-');
            var startTime = TimeSpan.Parse(openHours[0]);
            var endTime = TimeSpan.Parse(openHours[1]);

            var subFields = new List<SubFieldAvailabilityDto>();
            foreach (var subField in field.SubFields)
            {
                var slots = new List<TimeSlotDto>();
                var currentTime = startTime;

                while (currentTime < endTime)
                {
                    var slotEndTime = currentTime.Add(TimeSpan.FromHours(1));
                    var isBooked = subField.Bookings.Any(b =>
                        b.BookingDate.Date == date.Date &&
                        b.StartTime <= currentTime &&
                        b.EndTime > currentTime);

                    slots.Add(new TimeSlotDto
                    {
                        StartTime = currentTime.ToString(@"hh\:mm"), // Chỉ lấy giờ
                        EndTime = slotEndTime.ToString(@"hh\:mm"),   // Chỉ lấy giờ
                        Status = isBooked ? "Booked" : "Available"
                    });

                    currentTime = slotEndTime;
                }

                subFields.Add(new SubFieldAvailabilityDto
                {
                    SubFieldId = subField.SubFieldId,
                    Name = subField.SubFieldName,
                    PricePerHour = subField.PricePerHour,
                    Slots = slots
                });
            }

            return new FieldAvailabilityDto
            {
                FieldId = field.FieldId,
                FieldName = field.FieldName,
                Date = date.ToString("yyyy-MM-dd"),
                OpenHours = field.OpenHours,
                Services = field.FieldServices.Select(s => new FieldServiceAvailabilityDto
                {
                    Name = s.ServiceName,
                    Price = s.Price
                }).ToList(),
                SubFields = subFields
            };
        }

        private static FieldDto MapToFieldDto(Field field)
        {
            return new FieldDto
            {
                FieldId = field.FieldId,
                FieldName = field.FieldName,
                SportId = field.SportId,
                SportName = field.Sport?.SportName,
                Address = field.Address,
                Phone = field.Phone,
                OpenHours = field.OpenHours,
                Latitude = field.Latitude,
                Longitude = field.Longitude,
                Status = field.Status,
                Images = field.FieldImages.Select(i => i.ImageUrl).ToList(),
                Amenities = field.FieldAmenities.Select(a => new FieldAmenityDto
                {
                    AmenityName = a.AmenityName,
                    Description = a.Description
                }).ToList(),
                Services = field.FieldServices.Select(s => new FieldServiceDto
                {
                    Name = s.ServiceName,
                    Price = s.Price,
                    Description = s.Description
                }).ToList(),
                SubFields = field.SubFields.Select(sf => new SubFieldDto
                {
                    SubFieldId = sf.SubFieldId,
                    Name = sf.SubFieldName,
                    Size = sf.Size,
                    PricePerHour = sf.PricePerHour,
                    Status = sf.Status
                }).ToList()
            };
        }

        public async Task<PaginatedResponse<FieldReviewDto>> GetFieldReviewsAsync(
            int fieldId, int? rating, string sort, int page, int pageSize)
        {
            var query = _unitOfWork.Reviews.GetAll()
                .Include(r => r.User)
                .Where(r => r.FieldId == fieldId)
                .AsQueryable();

            if (rating.HasValue)
                query = query.Where(r => r.Rating == rating.Value);

            if (!string.IsNullOrEmpty(sort))
            {
                var sortParts = sort.Split(':');
                if (sortParts.Length == 2)
                {
                    var sortField = sortParts[0].ToLower();
                    var sortOrder = sortParts[1].ToLower();
                    query = sortField switch
                    {
                        "createdat" => sortOrder == "asc" ? query.OrderBy(r => r.CreatedAt) : query.OrderByDescending(r => r.CreatedAt),
                        "rating" => sortOrder == "asc" ? query.OrderBy(r => r.Rating) : query.OrderByDescending(r => r.Rating),
                        _ => query.OrderByDescending(r => r.CreatedAt)
                    };
                }
            }
            else
            {
                query = query.OrderByDescending(r => r.CreatedAt);
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldReviewDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(r => new FieldReviewDto
                {
                    ReviewId = r.ReviewId,
                    UserName = r.User?.FullName,
                    Rating = r.Rating,
                    Comment = r.Comment,
                    CreatedAt = r.CreatedAt
                }).ToList()
            };
        }

        public async Task<PaginatedResponse<FieldDto>> GetNearbyFieldsAsync(
            decimal latitude, decimal longitude, decimal radius, string sort, int page, int pageSize)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .Where(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude) <= radius)
                .AsQueryable();

            query = sort?.ToLower() switch
            {
                "distance" => query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude)),
                "rating" => query.OrderByDescending(f => f.Reviews.Average(r => r.Rating)),
                "price" => query.OrderBy(f => f.SubFields.Min(sf => sf.PricePerHour)),
                _ => query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude))
            };

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<PaginatedResponse<FieldDto>> SearchFieldsAsync(FieldSearchDto search)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .AsQueryable();

            if (!string.IsNullOrEmpty(search.SearchTerm))
            {
                var searchTermLower = search.SearchTerm.ToLower();
                query = query.Where(f =>
                    f.FieldName.ToLower().Contains(searchTermLower) ||
                    f.FieldDescriptions.Any(d => d.Description != null && d.Description.ToLower().Contains(searchTermLower)) ||
                    f.Address.ToLower().Contains(searchTermLower));
            }

            if (search.SportId.HasValue)
                query = query.Where(f => f.SportId == search.SportId.Value);

            if (search.MinPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour >= search.MinPrice.Value));

            if (search.MaxPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour <= search.MaxPrice.Value));

            if (search.Latitude.HasValue && search.Longitude.HasValue && search.Radius.HasValue)
            {
                query = query.Where(f =>
                    CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value) <= search.Radius.Value);
            }
            else if (!string.IsNullOrEmpty(search.Location))
            {
                var locationLower = search.Location.ToLower();
                query = query.Where(f => f.Address.ToLower().Contains(locationLower));
            }

            if (search.Time.HasValue)
            {
                var date = search.Time.Value.Date;
                var time = search.Time.Value.TimeOfDay;
                query = query.Where(f => f.SubFields.Any(sf =>
                    !sf.Bookings.Any(b => b.BookingDate.Date == date &&
                                         b.StartTime <= time && b.EndTime >= time)));
            }

            if (!string.IsNullOrEmpty(search.Sort))
            {
                switch (search.Sort.ToLower())
                {
                    case "rating:asc":
                        query = query.OrderBy(f => f.Reviews.Any() ? f.Reviews.Average(r => r.Rating) : 0);
                        break;
                    case "rating:desc":
                        query = query.OrderByDescending(f => f.Reviews.Any() ? f.Reviews.Average(r => r.Rating) : 0);
                        break;
                    case "price:asc":
                        query = query.OrderBy(f => f.SubFields.Any() ? f.SubFields.Min(sf => sf.PricePerHour) : 0);
                        break;
                    case "price:desc":
                        query = query.OrderByDescending(f => f.SubFields.Any() ? f.SubFields.Max(sf => sf.PricePerHour) : decimal.MaxValue);
                        break;
                    case "distance:asc":
                        if (search.Latitude.HasValue && search.Longitude.HasValue)
                            query = query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value));
                        break;
                    case "distance:desc":
                        if (search.Latitude.HasValue && search.Longitude.HasValue)
                            query = query.OrderByDescending(f => CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value));
                        break;
                    default:
                        query = query.OrderBy(f => f.FieldName);
                        break;
                }
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((search.Page - 1) * search.PageSize)
                .Take(search.PageSize)
                .Select(f => MapToFieldDto(f))
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = search.Page,
                PageSize = search.PageSize,
                Items = items
            };
        }

        public async Task ReportFieldAsync(int fieldId, FieldReportDto reportDto)
        {
            var field = await _unitOfWork.Fields.GetByIdAsync(fieldId);
            if (field == null)
                throw new ArgumentException("Field not found");

            _logger.LogInformation("Field {FieldId} reported: {Reason}", fieldId, reportDto.Reason);
            // TODO: Thêm logic lưu báo cáo vào DB nếu cần
        }

        public async Task<PaginatedResponse<FieldDto>> GetSuggestedFieldsAsync(
            decimal? latitude, decimal? longitude, int page, int pageSize)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .Where(f => f.Status == "Active")
                .AsQueryable();

            if (latitude.HasValue && longitude.HasValue)
            {
                query = query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude.Value, longitude.Value));
            }
            else
            {
                query = query.OrderByDescending(f => f.Reviews.Average(r => r.Rating));
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        private decimal CalculateDistance(decimal lat1, decimal lon1, decimal lat2, decimal lon2)
        {
            var R = 6371m; // Bán kính trái đất (km)
            var dLat = ToRad(lat2 - lat1);
            var dLon = ToRad(lon2 - lon1);
            var a = (decimal)Math.Sin((double)(dLat / 2)) * (decimal)Math.Sin((double)(dLat / 2)) +
                    (decimal)Math.Cos((double)ToRad(lat1)) * (decimal)Math.Cos((double)ToRad(lat2)) *
                    (decimal)Math.Sin((double)(dLon / 2)) * (decimal)Math.Sin((double)(dLon / 2));
            var c = 2 * (decimal)Math.Atan2(Math.Sqrt((double)a), Math.Sqrt(1 - (double)a));
            return R * c;
        }

        private decimal ToRad(decimal value)
        {
            return value * (decimal)Math.PI / 180;
        }
    }
}
using System.Net;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using api.Interfaces;

namespace api.Services
{
    public class GeocodingService : IGeocodingService
    {
        private readonly IConfiguration _configuration;
        private readonly HttpClient _httpClient;
        private readonly ILogger<GeocodingService> _logger;

        public GeocodingService(IConfiguration configuration, HttpClient httpClient, ILogger<GeocodingService> logger)
        {
            _configuration = configuration;
            _httpClient = httpClient;
            _logger = logger;
        }

        public async Task<(decimal latitude, decimal longitude)> GetCoordinatesFromAddressAsync(string address)
        {
            return await GetCoordinatesFromOpenCageAsync(address);
        }

        private async Task<(decimal latitude, decimal longitude)> GetCoordinatesFromOpenCageAsync(string address)
        {
            var apiKey = _configuration["Geocoding:OpenCageApiKey"];
            var baseUrl = _configuration["Geocoding:OpenCageGeocodingUrl"];

            if (string.IsNullOrEmpty(apiKey) || string.IsNullOrEmpty(baseUrl))
            {
                _logger.LogError("OpenCage API configuration is missing. Please check your configuration.");
                throw new Exception("Cấu hình API OpenCage không hợp lệ.");
            }

            _logger.LogInformation("Original address: {Address}", address);

            // Chuẩn hóa địa chỉ trước khi gọi API
            var addressParts = address.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(part => part.Trim())
                .Where(part => !string.IsNullOrWhiteSpace(part))
                .ToList();

            _logger.LogInformation("Address parts before normalization: {Parts}", string.Join(", ", addressParts));

            // Tạo địa chỉ tìm kiếm với các phần quan trọng
            var searchParts = new List<string>();
            
            // Thêm số nhà và tên đường
            var streetPart = addressParts.FirstOrDefault();
            if (!string.IsNullOrEmpty(streetPart))
            {
                searchParts.Add(streetPart);
            }

            // Thêm phường/xã
            var wardPart = addressParts.FirstOrDefault(p => p.Contains("Đông Hòa", StringComparison.OrdinalIgnoreCase));
            if (!string.IsNullOrEmpty(wardPart))
            {
                searchParts.Add(wardPart);
            }

            // Thêm quận/huyện
            searchParts.Add("Dĩ An");

            // Thêm tỉnh/thành
            searchParts.Add("Bình Dương");

            // Thêm quốc gia
            searchParts.Add("Việt Nam");

            // Nối các phần địa chỉ bằng khoảng trắng
            var normalizedAddress = string.Join(" ", searchParts);
            _logger.LogInformation("Final normalized address: {Address}", normalizedAddress);

            // URL encode toàn bộ địa chỉ
            var encodedAddress = WebUtility.UrlEncode(normalizedAddress);
            
            var url = $"{baseUrl}?q={encodedAddress}&key={apiKey}&language=vi&countrycode=vn&no_annotations=1&limit=1";

            _logger.LogInformation("Final encoded URL: {Url}", url.Replace(apiKey, "[REDACTED]"));

            try
            {
                _logger.LogDebug("Sending HTTP GET request to OpenCage API...");
                var response = await _httpClient.GetAsync(url);
                _logger.LogDebug("Received response with status code: {StatusCode}", response.StatusCode);

                var content = await response.Content.ReadAsStringAsync();
                _logger.LogDebug("Raw response content: {Content}", content);

                if (!response.IsSuccessStatusCode)
                {
                    _logger.LogError("OpenCage API returned non-success status code: {StatusCode}, Response: {Response}", 
                        response.StatusCode, content);
                    throw new HttpRequestException($"API trả về mã lỗi: {response.StatusCode}");
                }

                _logger.LogDebug("Deserializing response...");
                var result = JsonSerializer.Deserialize<OpenCageGeocodingResponse>(content);

                if (result == null)
                {
                    _logger.LogError("Failed to deserialize response. Response content: {Content}", content);
                    throw new Exception("Không thể xử lý phản hồi từ API.");
                }

                _logger.LogDebug("Response deserialized successfully. Status: {Code} - {Message}", 
                    result.Status?.Code, result.Status?.Message);

                if (result.Status != null && result.Status.Code != 200)
                {
                    _logger.LogError("OpenCage API returned error status: {Code} - {Message}", 
                        result.Status.Code, result.Status.Message);
                    throw new Exception($"API trả về lỗi: {result.Status.Message}");
                }

                if (result.Results == null || result.Results.Length == 0)
                {
                    _logger.LogWarning("No results found for address: {Address}", normalizedAddress);
                    throw new Exception($"Không tìm thấy tọa độ từ địa chỉ: {normalizedAddress}");
                }

                var firstResult = result.Results[0];
                _logger.LogDebug("First result: {Result}", JsonSerializer.Serialize(firstResult));

                if (firstResult.Geometry == null)
                {
                    _logger.LogError("Geometry is null in the first result. Full result: {Result}", 
                        JsonSerializer.Serialize(firstResult));
                    throw new Exception("Dữ liệu tọa độ không hợp lệ.");
                }

                var lat = firstResult.Geometry.Lat;
                var lng = firstResult.Geometry.Lng;

                _logger.LogInformation("Raw coordinates from API: Lat={Lat}, Lng={Lng}", lat, lng);

                // Chuyển đổi từ double sang decimal với độ chính xác phù hợp
                var coordinates = ((decimal)Math.Round(lat, 6), (decimal)Math.Round(lng, 6));
                _logger.LogDebug("Converted coordinates: Lat={Lat}, Lng={Lng}", coordinates.Item1, coordinates.Item2);

                return coordinates;
            }
            catch (HttpRequestException httpEx)
            {
                _logger.LogError(httpEx, "HTTP request to OpenCage failed for address: {Address}", normalizedAddress);
                throw;
            }
            catch (JsonException jsonEx)
            {
                _logger.LogError(jsonEx, "Failed to deserialize OpenCage response for address: {Address}", normalizedAddress);
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing OpenCage response for address: {Address}", normalizedAddress);
                throw;
            }
        }

        private class OpenCageGeocodingResponse
        {
            public OpenCageResult[] Results { get; set; }
            public OpenCageStatus Status { get; set; }
        }

        private class OpenCageResult
        {
            public OpenCageGeometry Geometry { get; set; }
            public OpenCageComponents Components { get; set; }
            public string Formatted { get; set; }
        }

        private class OpenCageGeometry
        {
            public double Lat { get; set; }
            public double Lng { get; set; }
        }

        private class OpenCageComponents
        {
            public string City { get; set; }
            public string State { get; set; }
            public string Country { get; set; }
        }

        private class OpenCageStatus
        {
            public int Code { get; set; }
            public string Message { get; set; }
        }
    }
}
using api.Interfaces;
using SendGrid;
using SendGrid.Helpers.Mail;

public class SendGridEmailSender : IEmailSender
{
    private readonly IConfiguration _configuration;

    public SendGridEmailSender(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    public async Task SendEmailAsync(string email, string subject, string htmlMessage)
    {
        var apiKey = _configuration["SendGrid:ApiKey"];
        var client = new SendGridClient(apiKey);
        var fromEmail = _configuration["SendGrid:FromEmail"];
        var fromName = _configuration["SendGrid:FromName"];
        var from = new EmailAddress(fromEmail, fromName);
        var to = new EmailAddress(email);
        var msg = MailHelper.CreateSingleEmail(from, to, subject, null, htmlMessage);
        var response = await client.SendEmailAsync(msg);

        if (response.StatusCode != System.Net.HttpStatusCode.OK && response.StatusCode != System.Net.HttpStatusCode.Accepted)
        {
            throw new Exception($"Failed to send email: {response.StatusCode}");
        }
    }
}
using System;
using System.Linq;
using System.Security.Claims;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using api.Data;
using api.Dtos;
using api.Dtos.User;
using api.Interfaces;
using api.Models;
using Microsoft.EntityFrameworkCore;

namespace api.Services
{
    public class UserService : IUserService
    {
        private readonly IUnitOfWork _unitOfWork;

        public UserService(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }

        private async Task<User> GetCurrentUserAsync(ClaimsPrincipal user)
        {
            var accountIdClaim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(accountIdClaim) || !int.TryParse(accountIdClaim, out int accountId))
            {
                throw new Exception("Token người dùng không hợp lệ.");
            }

            var dbUser = await _unitOfWork.Users.GetAll()
                .Include(u => u.Account)
                .FirstOrDefaultAsync(u => u.AccountId == accountId);
            if (dbUser == null)
            {
                throw new Exception("Không tìm thấy người dùng.");
            }

            return dbUser;
        }

        private async Task<Account> GetCurrentAccountAsync(ClaimsPrincipal user)
        {
            var accountIdClaim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(accountIdClaim) || !int.TryParse(accountIdClaim, out int accountId))
            {
                throw new Exception("Token người dùng không hợp lệ.");
            }

            var account = await _unitOfWork.Accounts.GetAll()
                .FirstOrDefaultAsync(a => a.AccountId == accountId);
            if (account == null)
            {
                throw new Exception("Không tìm thấy tài khoản.");
            }

            return account;
        }

        public async Task<UserProfileResponseDto> GetUserProfileAsync(ClaimsPrincipal user)
        {
            var account = await GetCurrentAccountAsync(user);
            var role = account.Role;

            if (role == "User")
            {
                var dbUser = await _unitOfWork.Users.GetAll()
                    .Include(u => u.Account)
                    .FirstOrDefaultAsync(u => u.AccountId == account.AccountId);
                if (dbUser == null)
                {
                    throw new Exception("Không tìm thấy thông tin người dùng.");
                }

                return new UserProfileResponseDto
                {
                    Email = dbUser.Email,
                    Role = account.Role,
                    FullName = dbUser.FullName,
                    Phone = dbUser.Phone,
                    Gender = dbUser.Gender,
                    DateOfBirth = dbUser.DateOfBirth?.ToString("yyyy-MM-dd"),
                    // AvatarUrl = dbUser.AvatarUrl
                };
            }
            else if (role == "Owner")
            {
                var dbOwner = await _unitOfWork.Owners.GetAll()
                    .Include(o => o.Account)
                    .FirstOrDefaultAsync(o => o.AccountId == account.AccountId);
                if (dbOwner == null)
                {
                    throw new Exception("Không tìm thấy thông tin chủ sân.");
                }

                return new UserProfileResponseDto
                {
                    Email = dbOwner.Email,
                    Role = account.Role,
                    FullName = dbOwner.FullName,
                    Phone = dbOwner.Phone,
                    Gender = null, // Owner không có trường Gender
                    DateOfBirth = null, // Owner không có trường DateOfBirth
                    // AvatarUrl = null // Owner không có trường AvatarUrl 
                };
            }
            else
            {
                throw new Exception("Vai trò không được hỗ trợ.");
            }
        }

        public async Task UpdateUserProfileAsync(ClaimsPrincipal user, UpdateProfileDto updateProfileDto)
        {
            var account = await GetCurrentAccountAsync(user);
            var role = account.Role;

            // Kiểm tra định dạng số điện thoại
            if (!string.IsNullOrEmpty(updateProfileDto.Phone) && !Regex.IsMatch(updateProfileDto.Phone, @"^[0-9]{10}$"))
            {
                throw new Exception("Số điện thoại không hợp lệ, phải là 10 chữ số.");
            }

            if (role == "User")
            {
                var dbUser = await _unitOfWork.Users.GetAll()
                    .FirstOrDefaultAsync(u => u.AccountId == account.AccountId);
                if (dbUser == null)
                {
                    throw new Exception("Không tìm thấy người dùng.");
                }

                // Cập nhật các trường bắt buộc
                dbUser.FullName = updateProfileDto.FullName;
                dbUser.Phone = updateProfileDto.Phone;
                dbUser.Gender = updateProfileDto.Gender;
                dbUser.DateOfBirth = updateProfileDto.DateOfBirth;

                _unitOfWork.Users.Update(dbUser);
            }
            else if (role == "Owner")
            {
                var dbOwner = await _unitOfWork.Owners.GetAll()
                    .FirstOrDefaultAsync(o => o.AccountId == account.AccountId);
                if (dbOwner == null)
                {
                    throw new Exception("Không tìm thấy chủ sân.");
                }

                dbOwner.FullName = updateProfileDto.FullName;
                dbOwner.Phone = updateProfileDto.Phone;
                dbOwner.UpdatedAt = DateTime.UtcNow; // Cập nhật thời gian chỉnh sửa

                _unitOfWork.Owners.Update(dbOwner);
            }
            else
            {
                throw new Exception("Vai trò không được hỗ trợ.");
            }

            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<PaginatedResponse<Booking>> GetUserBookingsAsync(ClaimsPrincipal user, string status, DateTime? date, string sort, int page, int pageSize)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User
            var query = _unitOfWork.Bookings.GetAll()
                .Include(b => b.SubField)
                .Where(b => b.UserId == dbUser.UserId)
                .AsQueryable();

            if (!string.IsNullOrEmpty(status))
            {
                query = query.Where(b => b.Status == status);
            }

            if (date.HasValue)
            {
                query = query.Where(b => b.BookingDate.Date == date.Value.Date);
            }

            if (!string.IsNullOrEmpty(sort))
            {
                var sortParts = sort.Split(':');
                var sortField = sortParts[0];
                var sortDirection = sortParts.Length > 1 ? sortParts[1].ToLower() : "asc";

                query = sortField switch
                {
                    "BookingDate" => sortDirection == "desc" ? query.OrderByDescending(b => b.BookingDate) : query.OrderBy(b => b.BookingDate),
                    "CreatedAt" => sortDirection == "desc" ? query.OrderByDescending(b => b.CreatedAt) : query.OrderBy(b => b.CreatedAt), // Sửa lỗi typo
                    _ => query.OrderBy(b => b.BookingDate)
                };
            }
            else
            {
                query = query.OrderBy(b => b.BookingDate);
            }

            var totalItems = await query.CountAsync();
            var items = await query.Skip((page - 1) * pageSize).Take(pageSize).ToListAsync();

            return new PaginatedResponse<Booking>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items
            };
        }

        public async Task DeactivateUserAsync(ClaimsPrincipal user)
        {
            var account = await GetCurrentAccountAsync(user);
            account.IsActive = false;
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<PaginatedResponse<FavoriteField>> GetFavoriteFieldsAsync(ClaimsPrincipal user, string sort, int page, int pageSize)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User
            var query = _unitOfWork.FavoriteFields.GetAll()
                .Include(ff => ff.Field)
                    .ThenInclude(f => f.Sport)
                .Where(ff => ff.UserId == dbUser.UserId)
                .AsQueryable();

            if (!string.IsNullOrEmpty(sort))
            {
                var sortParts = sort.Split(':');
                var sortField = sortParts[0];
                var sortDirection = sortParts.Length > 1 ? sortParts[1].ToLower() : "asc";

                query = sortField switch
                {
                    "AddedDate" => sortDirection == "desc" ? query.OrderByDescending(ff => ff.AddedDate) : query.OrderBy(ff => ff.AddedDate),
                    "FieldName" => sortDirection == "desc" ? query.OrderByDescending(ff => ff.Field.FieldName) : query.OrderBy(ff => ff.Field.FieldName),
                    _ => query.OrderBy(ff => ff.AddedDate)
                };
            }
            else
            {
                query = query.OrderBy(ff => ff.AddedDate);
            }

            var totalItems = await query.CountAsync();
            var items = await query.Skip((page - 1) * pageSize).Take(pageSize).ToListAsync();

            return new PaginatedResponse<FavoriteField>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items
            };
        }

        public async Task AddFavoriteFieldAsync(ClaimsPrincipal user, int fieldId)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User

            var field = await _unitOfWork.Fields.GetAll().FirstOrDefaultAsync(f => f.FieldId == fieldId);
            if (field == null)
            {
                throw new Exception("Field does not exist.");
            }

            var existingFavorite = await _unitOfWork.FavoriteFields.GetAll()
                .FirstOrDefaultAsync(f => f.FieldId == fieldId && f.UserId == dbUser.UserId);
            if (existingFavorite != null)
            {
                throw new Exception("Field already in favorites.");
            }

            var favorite = new FavoriteField
            {
                UserId = dbUser.UserId,
                FieldId = fieldId,
                AddedDate = DateTime.UtcNow
            };

            await _unitOfWork.FavoriteFields.AddAsync(favorite);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task RemoveFavoriteFieldAsync(ClaimsPrincipal user, int fieldId)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User
            var favorite = await _unitOfWork.FavoriteFields.GetAll()
                .FirstOrDefaultAsync(ff => ff.UserId == dbUser.UserId && ff.FieldId == fieldId);

            if (favorite == null)
            {
                throw new Exception("Field not found in favorites.");
            }

            _unitOfWork.FavoriteFields.Delete(favorite);
            await _unitOfWork.SaveChangesAsync();
        }
    }
}

using System.Security.Claims;
using System.Threading.Tasks;
using api.Dtos;
using api.Dtos.Booking;
using api.Interfaces;
using api.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using Microsoft.Extensions.Logging;

namespace api.Controllers
{
    [Route("api/booking")]
    [ApiController]
    [EnableRateLimiting("auth")]
    [Authorize]
    public class BookingController : ControllerBase
    {
        private readonly IBookingService _bookingService;
        private readonly ILogger<BookingController> _logger;

        public BookingController(IBookingService bookingService, ILogger<BookingController> logger)
        {
            _bookingService = bookingService;
            _logger = logger;
        }

        [HttpPost]
        [Authorize(Roles = "User")]
        public async Task<IActionResult> CreateBooking([FromBody] CreateBookingDto createBookingDto)
        {
            try
            {
                _logger.LogInformation("Creating booking for user: {UserId}", User.FindFirst(ClaimTypes.NameIdentifier)?.Value);
                var booking = await _bookingService.CreateBookingAsync(User, createBookingDto);
                return CreatedAtAction(nameof(GetBooking), new { id = booking.BookingId }, booking);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating booking");
                return BadRequest(new { Message = ex.Message, InnerException = ex.InnerException?.Message });
            }
        }

        [HttpGet]
        public async Task<IActionResult> GetBookings(
            [FromQuery] string status = null,
            [FromQuery] int? fieldId = null,
            [FromQuery] string sort = "BookingDate:desc",
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 10)
        {
            _logger.LogInformation("Getting bookings for user: {UserId}", User.FindFirst(ClaimTypes.NameIdentifier)?.Value);
            var bookings = await _bookingService.GetBookingsAsync(User, status, fieldId, sort, page, pageSize);
            return Ok(bookings);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> GetBooking(int id)
        {
            var booking = await _bookingService.GetBookingByIdAsync(User, id);
            if (booking == null) return NotFound("Không tìm thấy đơn đặt sân.");
            return Ok(booking);
        }

        [HttpPut("{id}")]
        [Authorize(Roles = "User")]
        public async Task<IActionResult> UpdateBooking(int id, [FromBody] UpdateBookingDto updateBookingDto)
        {
            try
            {
                var booking = await _bookingService.UpdateBookingAsync(User, id, updateBookingDto);
                if (booking == null) return NotFound("Không tìm thấy đơn đặt sân.");
                return Ok(booking);
            }
            catch (Exception ex)
            {
                return BadRequest(ex.Message);
            }
        }

        [HttpDelete("{id}")]
        [Authorize(Roles = "User")]
        public async Task<IActionResult> CancelBooking(int id)
        {
            try
            {
                await _bookingService.CancelBookingAsync(User, id);
                return NoContent();
            }
            catch (Exception ex)
            {
                return BadRequest(ex.Message);
            }
        }

        [HttpPut("{id}/status")]
        [Authorize(Roles = "Owner")]
        public async Task<IActionResult> UpdateBookingStatus(int id, [FromBody] UpdateBookingStatusDto statusDto)
        {
            var booking = await _bookingService.UpdateBookingStatusAsync(User, id, statusDto.Status);
            if (booking == null) return Forbid("Không có quyền cập nhật trạng thái.");
            return Ok(booking);
        }

        [HttpGet("{id}/services")]
        public async Task<IActionResult> GetBookingServices(int id)
        {
            var services = await _bookingService.GetBookingServicesAsync(User, id);
            if (services == null) return NotFound("Không tìm thấy đơn đặt sân.");
            return Ok(services);
        }

        [HttpPost("preview")]
        [Authorize(Roles = "User")]
        public async Task<IActionResult> PreviewBooking([FromBody] CreateBookingDto createBookingDto)
        {
            try
            {
                var preview = await _bookingService.PreviewBookingAsync(createBookingDto);
                return Ok(preview);
            }
            catch (Exception ex)
            {
                return BadRequest(ex.Message);
            }
        }
    }
}