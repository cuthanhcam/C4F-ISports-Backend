using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using api.Data;
using api.Dtos.Auth;
using api.Interfaces;
using api.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;

namespace api.Services
{
    public class AuthService : IAuthService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IConfiguration _configuration;
        private readonly IEmailSender _emailSender;

        public AuthService(IUnitOfWork unitOfWork, IConfiguration configuration, IEmailSender emailSender)
        {
            _unitOfWork = unitOfWork;
            _configuration = configuration;
            _emailSender = emailSender;
        }

        public async Task<(string Token, string RefreshToken)> RegisterAsync(RegisterDto registerDto)
        {
            if (registerDto.Role == "Admin")
            {
                throw new Exception("Không thể đăng ký tài khoản với vai trò Admin.");
            }

            if (_unitOfWork.Accounts.GetAll().Any(a => a.Email == registerDto.Email))
            {
                throw new Exception("Email đã tồn tại.");
            }

            var account = new Account
            {
                Email = registerDto.Email,
                Password = BCrypt.Net.BCrypt.HashPassword(registerDto.Password),
                Role = registerDto.Role,
                IsActive = false,
                CreatedAt = DateTime.UtcNow,
                VerificationToken = Guid.NewGuid().ToString(),
                VerificationTokenExpiry = DateTime.UtcNow.AddHours(24)
            };

            await _unitOfWork.Accounts.AddAsync(account);
            await _unitOfWork.SaveChangesAsync();

            if (registerDto.Role == "User")
            {
                var user = new User
                {
                    AccountId = account.AccountId,
                    FullName = registerDto.FullName,
                    Email = registerDto.Email,
                    Phone = registerDto.Phone,
                    DateOfBirth = null,
                    Gender = "Unknown"
                };
                await _unitOfWork.Users.AddAsync(user);
            }
            else if (registerDto.Role == "Owner")
            {
                var owner = new Owner
                {
                    AccountId = account.AccountId,
                    FullName = registerDto.FullName,
                    Email = registerDto.Email,
                    Phone = registerDto.Phone,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };
                await _unitOfWork.Owners.AddAsync(owner);
            }

            await _unitOfWork.SaveChangesAsync();

            // Gửi email xác thực
            var verificationLink = $"{_configuration["AppUrl"]}/api/auth/verify-email?email={account.Email}&token={account.VerificationToken}";
            var emailSubject = "Xác thực tài khoản C4F ISports";
            var emailBody = $"<h3>Xin chào {registerDto.FullName},</h3>" +
                            $"<p>Vui lòng nhấp vào liên kết sau để xác thực email của bạn:</p>" +
                            $"<a href='{verificationLink}'>Xác thực ngay</a>" +
                            $"<p>Liên kết này có hiệu lực trong 24 giờ.</p>" +
                            $"<p>Trân trọng,<br/>Đội ngũ C4F ISports</p>";
            await _emailSender.SendEmailAsync(account.Email, emailSubject, emailBody);

            var token = GenerateJwtToken(account);
            var refreshToken = await GenerateRefreshTokenAsync(account);
            return (token, refreshToken.Token);
        }

        public async Task<(string Token, string RefreshToken)> LoginAsync(LoginDto loginDto)
        {
            var account = await _unitOfWork.Accounts.GetAll()
                .Include(a => a.User)
                .Include(a => a.Owner)
                .FirstOrDefaultAsync(a => a.Email == loginDto.Email);

            if (account == null || !BCrypt.Net.BCrypt.Verify(loginDto.Password, account.Password))
            {
                throw new Exception("Email hoặc mật khẩu không chính xác.");
            }

            if (!account.IsActive)
            {
                throw new Exception("Tài khoản chưa được xác thực. Vui lòng kiểm tra email của bạn.");
            }

            account.LastLogin = DateTime.UtcNow;
            await _unitOfWork.SaveChangesAsync();

            var token = GenerateJwtToken(account);
            var refreshToken = await GenerateRefreshTokenAsync(account);
            return (token, refreshToken.Token);
        }

        public async Task<(string Token, string RefreshToken)> RefreshTokenAsync(string refreshToken)
        {
            var token = _unitOfWork.RefreshTokens.GetAll()
                .FirstOrDefault(t => t.Token == refreshToken && t.Expires > DateTime.UtcNow && !t.Revoked.HasValue);

            if (token == null)
            {
                throw new Exception("Invalid or expired refresh token.");
            }

            var account = await _unitOfWork.Accounts.GetByIdAsync(token.AccountId);
            if (account == null)
            {
                throw new Exception("Account not found.");
            }

            var newToken = GenerateJwtToken(account);
            var newRefreshToken = await GenerateRefreshTokenAsync(account);
            token.Revoked = DateTime.UtcNow;
            token.ReplacedByToken = newRefreshToken.Token;
            _unitOfWork.RefreshTokens.Update(token);
            await _unitOfWork.SaveChangesAsync();

            return (newToken, newRefreshToken.Token);
        }

        public async Task ForgotPasswordAsync(string email)
        {
            var account = _unitOfWork.Accounts.GetAll().FirstOrDefault(a => a.Email == email);

            if (account == null)
            {
                throw new Exception("Email not found.");
            }

            var resetToken = Guid.NewGuid().ToString();
            account.ResetToken = resetToken;
            account.ResetTokenExpiry = DateTime.UtcNow.AddHours(1);
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();

            // Gửi email reset password
            var resetLink = $"{_configuration["FEUrl"]}/auth/reset-password?email={account.Email}&token={resetToken}";
            var emailSubject = "Đặt lại mật khẩu C4F ISports";
            var emailBody = $"<h3>Xin chào {account.Email},</h3>" +
                            $"<p>Bạn đã yêu cầu đặt lại mật khẩu. Nhấp vào liên kết sau để tiếp tục:</p>" +
                            $"<a href='{resetLink}'>Đặt lại mật khẩu</a>" +
                            $"<p>Liên kết này có hiệu lực trong 1 giờ.</p>" +
                            $"<p>Trân trọng,<br/>Đội ngũ C4F ISports</p>";
            await _emailSender.SendEmailAsync(account.Email, emailSubject, emailBody);
        }

        public async Task ResetPasswordAsync(ResetPasswordDto resetPasswordDto)
        {
            var account = _unitOfWork.Accounts.GetAll()
                .FirstOrDefault(a => a.Email == resetPasswordDto.Email && a.ResetToken == resetPasswordDto.Token);

            if (account == null || account.ResetTokenExpiry < DateTime.UtcNow)
            {
                throw new Exception("Invalid or expired reset token.");
            }

            account.Password = BCrypt.Net.BCrypt.HashPassword(resetPasswordDto.NewPassword);
            account.ResetToken = null;
            account.ResetTokenExpiry = null;
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task LogoutAsync(string refreshToken)
        {
            var token = _unitOfWork.RefreshTokens.GetAll().FirstOrDefault(t => t.Token == refreshToken);
            if (token != null)
            {
                token.Revoked = DateTime.UtcNow;
                _unitOfWork.RefreshTokens.Update(token);
                await _unitOfWork.SaveChangesAsync();
            }
        }

        public async Task<bool> VerifyTokenAsync(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_configuration["JwtSettings:Secret"]);
            try
            {
                tokenHandler.ValidateToken(token, new TokenValidationParameters
                {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ValidateLifetime = true
                }, out _);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<bool> VerifyEmailAsync(string email, string token)
        {
            var account = _unitOfWork.Accounts.GetAll()
                .FirstOrDefault(a => a.Email == email && a.VerificationToken == token);

            if (account == null || account.VerificationTokenExpiry < DateTime.UtcNow)
            {
                throw new Exception("Invalid or expired verification token.");
            }

            if (account.IsActive)
            {
                throw new Exception("Email already verified.");
            }

            account.IsActive = true;
            account.VerificationToken = null;
            account.VerificationTokenExpiry = null;
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();

            return true;
        }

        public async Task ResendVerificationEmailAsync(string email)
        {
            var account = await _unitOfWork.Accounts.GetAll()
                .FirstOrDefaultAsync(a => a.Email == email);

            if (account == null)
            {
                throw new Exception("Email không tồn tại trong hệ thống.");
            }

            if (account.IsActive)
            {
                throw new Exception("Tài khoản đã được kích hoạt, không cần gửi lại email xác thực.");
            }

            // Tạo mới VerificationToken
            account.VerificationToken = Guid.NewGuid().ToString();
            account.VerificationTokenExpiry = DateTime.UtcNow.AddHours(24); // Token có hiệu lực 24 giờ
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();

            // Gửi email xác thực
            var verificationLink = $"{_configuration["AppUrl"]}/api/auth/verify-email?email={account.Email}&token={account.VerificationToken}";
            var emailSubject = "Xác thực lại tài khoản C4F ISports";
            var emailBody = $"<h3>Xin chào {account.Email},</h3>" +
                            $"<p>Bạn đã yêu cầu gửi lại email xác thực. Vui lòng nhấp vào liên kết sau để xác thực tài khoản:</p>" +
                            $"<a href='{verificationLink}'>Xác thực ngay</a>" +
                            $"<p>Liên kết này có hiệu lực trong 24 giờ.</p>" +
                            $"<p>Trân trọng,<br/>Đội ngũ C4F ISports</p>";
            await _emailSender.SendEmailAsync(account.Email, emailSubject, emailBody);
        }

        private string GenerateJwtToken(Account account)
        {
            var claims = new[]
            {
                new Claim(ClaimTypes.NameIdentifier, account.AccountId.ToString()),
                new Claim(ClaimTypes.Email, account.Email),
                new Claim(ClaimTypes.Role, account.Role)
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["JwtSettings:Secret"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var token = new JwtSecurityToken(
                claims: claims,
                expires: DateTime.UtcNow.AddMinutes(int.Parse(_configuration["JwtSettings:TokenExpiryMinutes"])),
                signingCredentials: creds);

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        private async Task<RefreshToken> GenerateRefreshTokenAsync(Account account)
        {
            var refreshToken = new RefreshToken
            {
                AccountId = account.AccountId,
                Token = Guid.NewGuid().ToString(),
                Expires = DateTime.UtcNow.AddDays(int.Parse(_configuration["JwtSettings:RefreshTokenExpiryDays"])),
                Created = DateTime.UtcNow
            };
            await _unitOfWork.RefreshTokens.AddAsync(refreshToken);
            await _unitOfWork.SaveChangesAsync();
            return refreshToken;
        }

        public async Task<Account> GetCurrentUserAsync(ClaimsPrincipal user)
        {
            var accountIdClaim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(accountIdClaim) || !int.TryParse(accountIdClaim, out int accountId))
            {
                throw new Exception("Invalid user token.");
            }

            var account = await _unitOfWork.Accounts.GetAll()
                .Include(a => a.User)
                .Include(a => a.Owner)
                .FirstOrDefaultAsync(a => a.AccountId == accountId);
            if (account == null)
            {
                throw new Exception("User not found.");
            }

            return account;
        }

        public async Task ChangePasswordAsync(ClaimsPrincipal user, ChangePasswordDto changePasswordDto)
        {
            var account = await GetCurrentUserAsync(user);

            if (!BCrypt.Net.BCrypt.Verify(changePasswordDto.OldPassword, account.Password))
            {
                throw new Exception("Old password is incorrect.");
            }

            account.Password = BCrypt.Net.BCrypt.HashPassword(changePasswordDto.NewPassword);
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using api.Dtos;
using api.Dtos.Booking;
using api.Interfaces;
using api.Models;
using Microsoft.EntityFrameworkCore;

namespace api.Services
{
    public class BookingService : IBookingService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly ILogger<BookingService> _logger;

        public BookingService(IUnitOfWork unitOfWork, ILogger<BookingService> logger)
        {
            _logger = logger;
            _unitOfWork = unitOfWork;
        }

        public async Task<BookingDto> CreateBookingAsync(ClaimsPrincipal user, CreateBookingDto createBookingDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier).Value);
            _logger.LogInformation("Creating booking for AccountId: {AccountId}, SubFieldId: {SubFieldId}", accountId, createBookingDto.SubFieldId);

            var userEntity = await _unitOfWork.Users.GetAll()
                .FirstOrDefaultAsync(u => u.AccountId == accountId);
            if (userEntity == null) throw new Exception($"Không tìm thấy User liên kết với AccountId {accountId}.");
            var userId = userEntity.UserId;
            _logger.LogInformation("Mapped AccountId {AccountId} to UserId {UserId}", accountId, userId);

            var subField = await _unitOfWork.SubFields.GetByIdAsync(createBookingDto.SubFieldId);
            if (subField == null) throw new Exception("Sân nhỏ không tồn tại.");

            var bookingDate = DateTime.Parse(createBookingDto.BookingDate);
            var startTime = TimeSpan.Parse(createBookingDto.StartTime);
            var endTime = TimeSpan.Parse(createBookingDto.EndTime);
            var duration = (endTime - startTime).TotalHours;

            var isAvailable = !await _unitOfWork.Bookings.AnyAsync(b =>
                b.SubFieldId == createBookingDto.SubFieldId &&
                b.BookingDate == bookingDate &&
                b.StartTime < endTime && b.EndTime > startTime &&
                b.Status != "Canceled");
            if (!isAvailable) throw new Exception("Khung giờ đã được đặt.");

            decimal totalPrice = (decimal)duration * subField.PricePerHour;
            var booking = new Booking
            {
                UserId = userId,
                SubFieldId = createBookingDto.SubFieldId,
                BookingDate = bookingDate,
                StartTime = startTime,
                EndTime = endTime,
                TotalPrice = totalPrice,
                Status = "Pending",
                PaymentStatus = "Unpaid",
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            await _unitOfWork.Bookings.AddAsync(booking);
            await _unitOfWork.SaveChangesAsync();

            var bookingServices = new List<Models.BookingService>();
            if (createBookingDto.ServiceIds != null && createBookingDto.ServiceIds.Any())
            {
                var fieldServices = await _unitOfWork.FieldServices.FindAsync(fs =>
                    createBookingDto.ServiceIds.Contains(fs.FieldServiceId));
                _logger.LogInformation("Found {Count} field services for SubFieldId {SubFieldId}", fieldServices.Count(), createBookingDto.SubFieldId);
                foreach (var service in fieldServices)
                {
                    totalPrice += service.Price;
                    bookingServices.Add(new Models.BookingService
                    {
                        BookingId = booking.BookingId,
                        FieldServiceId = service.FieldServiceId,
                        Quantity = 1,
                        Price = service.Price
                    });
                }
                if (bookingServices.Any())
                {
                    await _unitOfWork.BookingServices.AddRangeAsync(bookingServices);
                    booking.TotalPrice = totalPrice;
                    _unitOfWork.Bookings.Update(booking);
                    await _unitOfWork.SaveChangesAsync();
                }
            }

            return await MapToBookingDto(booking);
        }

        public async Task<PaginatedResponse<BookingDto>> GetBookingsAsync(
            ClaimsPrincipal user,
            string? status = null, // Thay đổi thành nullable
            int? fieldId = null,
            string? sort = null,
            int page = 1,
            int pageSize = 10)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier).Value);
            var isOwner = user.IsInRole("Owner");
            int? userId = null;
            int? ownerId = null;

            // Kiểm tra role và lấy ID tương ứng
            if (isOwner)
            {
                var owner = await _unitOfWork.Owners.GetAll()
                    .FirstOrDefaultAsync(o => o.AccountId == accountId);
                if (owner == null) throw new Exception($"Không tìm thấy Owner liên kết với AccountId {accountId}.");
                ownerId = owner.OwnerId;
            }
            else
            {
                var userEntity = await _unitOfWork.Users.GetAll()
                    .FirstOrDefaultAsync(u => u.AccountId == accountId);
                if (userEntity == null) throw new Exception($"Không tìm thấy User liên kết với AccountId {accountId}.");
                userId = userEntity.UserId;
            }

            var query = _unitOfWork.Bookings.GetAll();

            // Lọc booking dựa trên role
            if (isOwner && ownerId.HasValue)
            {
                query = query.Where(b => _unitOfWork.SubFields.GetAll()
                    .Include(sf => sf.Field)
                    .Any(sf => sf.SubFieldId == b.SubFieldId && sf.Field.OwnerId == ownerId.Value));
                if (fieldId.HasValue)
                {
                    query = query.Where(b => _unitOfWork.SubFields.GetAll()
                        .Any(sf => sf.SubFieldId == b.SubFieldId && sf.FieldId == fieldId.Value));
                }
            }
            else if (userId.HasValue)
            {
                query = query.Where(b => b.UserId == userId.Value);
            }
            else
            {
                throw new Exception("Không thể xác định người dùng hoặc chủ sân.");
            }

            if (!string.IsNullOrEmpty(status))
            {
                query = query.Where(b => b.Status == status);
            }

            query = query
                .Include(b => b.SubField).ThenInclude(sf => sf.Field)
                .Include(b => b.BookingServices).ThenInclude(bs => bs.FieldService);

            var totalItems = await query.CountAsync();
            query = ApplySorting(query, sort);

            var bookingEntities = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            var bookings = new List<BookingDto>();
            foreach (var booking in bookingEntities)
            {
                bookings.Add(await MapToBookingDto(booking));
            }

            return new PaginatedResponse<BookingDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = bookings
            };
        }

        public async Task<BookingDto> GetBookingByIdAsync(ClaimsPrincipal user, int bookingId)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier).Value);
            var isOwner = user.IsInRole("Owner");
            int? userId = null;
            int? ownerId = null;

            // Kiểm tra role và lấy ID tương ứng
            if (isOwner)
            {
                var owner = await _unitOfWork.Owners.GetAll()
                    .FirstOrDefaultAsync(o => o.AccountId == accountId);
                if (owner == null) throw new Exception($"Không tìm thấy Owner liên kết với AccountId {accountId}.");
                ownerId = owner.OwnerId;
            }
            else
            {
                var userEntity = await _unitOfWork.Users.GetAll()
                    .FirstOrDefaultAsync(u => u.AccountId == accountId);
                if (userEntity == null) throw new Exception($"Không tìm thấy User liên kết với AccountId {accountId}.");
                userId = userEntity.UserId;
            }

            var booking = await _unitOfWork.Bookings.GetAll()
                .Include(b => b.SubField).ThenInclude(sf => sf.Field)
                .Include(b => b.BookingServices).ThenInclude(bs => bs.FieldService)
                .FirstOrDefaultAsync(b => b.BookingId == bookingId);

            if (booking == null) return null;

            if (!isOwner && userId.HasValue && booking.UserId != userId.Value) return null;
            if (isOwner && ownerId.HasValue && booking.SubField.Field.OwnerId != ownerId.Value) return null;

            return await MapToBookingDto(booking);
        }

        public async Task<BookingDto> UpdateBookingAsync(ClaimsPrincipal user, int bookingId, UpdateBookingDto updateBookingDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier).Value);
            var userEntity = await _unitOfWork.Users.GetAll()
                .FirstOrDefaultAsync(u => u.AccountId == accountId);
            if (userEntity == null) throw new Exception($"Không tìm thấy User liên kết với AccountId {accountId}.");
            var userId = userEntity.UserId;

            var booking = await _unitOfWork.Bookings.GetAll()
                .Include(b => b.BookingServices)
                .FirstOrDefaultAsync(b => b.BookingId == bookingId && b.UserId == userId);
            if (booking == null) return null;
            if (booking.Status != "Pending" || booking.PaymentStatus != "Unpaid")
                throw new Exception("Không thể chỉnh sửa booking đã xác nhận hoặc đã thanh toán.");

            var subField = await _unitOfWork.SubFields.GetByIdAsync(booking.SubFieldId);
            var bookingDate = DateTime.Parse(updateBookingDto.BookingDate);
            var startTime = TimeSpan.Parse(updateBookingDto.StartTime);
            var endTime = TimeSpan.Parse(updateBookingDto.EndTime);
            var duration = (endTime - startTime).TotalHours;

            var isAvailable = !await _unitOfWork.Bookings.AnyAsync(b =>
                b.SubFieldId == booking.SubFieldId &&
                b.BookingId != bookingId &&
                b.BookingDate == bookingDate &&
                b.StartTime < endTime && b.EndTime > startTime &&
                b.Status != "Canceled");
            if (!isAvailable) throw new Exception("Khung giờ đã được đặt.");

            booking.BookingDate = bookingDate;
            booking.StartTime = startTime;
            booking.EndTime = endTime;
            booking.UpdatedAt = DateTime.UtcNow;

            decimal totalPrice = (decimal)duration * subField.PricePerHour;
            var existingServices = booking.BookingServices.ToList();
            foreach (var service in existingServices)
            {
                await _unitOfWork.BookingServices.DeleteAsync(service);
            }

            var bookingServices = new List<Models.BookingService>();
            if (updateBookingDto.ServiceIds != null && updateBookingDto.ServiceIds.Any())
            {
                var fieldServices = await _unitOfWork.FieldServices.FindAsync(fs =>
                    updateBookingDto.ServiceIds.Contains(fs.FieldServiceId) && fs.FieldId == subField.FieldId);
                foreach (var service in fieldServices)
                {
                    totalPrice += service.Price;
                    bookingServices.Add(new Models.BookingService
                    {
                        BookingId = booking.BookingId,
                        FieldServiceId = service.FieldServiceId,
                        Quantity = 1,
                        Price = service.Price
                    });
                }
            }
            booking.TotalPrice = totalPrice;

            if (bookingServices.Any())
            {
                await _unitOfWork.BookingServices.AddRangeAsync(bookingServices);
            }

            _unitOfWork.Bookings.Update(booking);
            await _unitOfWork.SaveChangesAsync();
            return await MapToBookingDto(booking);
        }

        public async Task CancelBookingAsync(ClaimsPrincipal user, int bookingId)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier).Value);
            var userEntity = await _unitOfWork.Users.GetAll()
                .FirstOrDefaultAsync(u => u.AccountId == accountId);
            if (userEntity == null) throw new Exception($"Không tìm thấy User liên kết với AccountId {accountId}.");
            var userId = userEntity.UserId;

            var booking = await _unitOfWork.Bookings.GetAll()
                .FirstOrDefaultAsync(b => b.BookingId == bookingId && b.UserId == userId);
            if (booking == null) throw new Exception("Không tìm thấy booking.");
            if (booking.Status != "Pending" || booking.PaymentStatus != "Unpaid")
                throw new Exception("Không thể hủy booking đã xác nhận hoặc đã thanh toán.");

            booking.Status = "Canceled";
            booking.UpdatedAt = DateTime.UtcNow;
            _unitOfWork.Bookings.Update(booking);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<BookingDto> UpdateBookingStatusAsync(ClaimsPrincipal user, int bookingId, string status)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier).Value);
            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (owner == null) throw new Exception($"Không tìm thấy Owner liên kết với AccountId {accountId}.");
            var ownerId = owner.OwnerId;

            var booking = await _unitOfWork.Bookings.GetAll()
                .Include(b => b.SubField).ThenInclude(sf => sf.Field)
                .Include(b => b.BookingServices).ThenInclude(bs => bs.FieldService)
                .FirstOrDefaultAsync(b => b.BookingId == bookingId);
            if (booking == null) return null;
            if (booking.SubField.Field.OwnerId != ownerId) return null;

            booking.Status = status;
            booking.UpdatedAt = DateTime.UtcNow;
            _unitOfWork.Bookings.Update(booking);
            await _unitOfWork.SaveChangesAsync();
            return await MapToBookingDto(booking);
        }

        public async Task<List<BookingServiceDto>> GetBookingServicesAsync(ClaimsPrincipal user, int bookingId)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier).Value);
            var userEntity = await _unitOfWork.Users.GetAll()
                .FirstOrDefaultAsync(u => u.AccountId == accountId);
            var isOwner = user.IsInRole("Owner");
            var userId = userEntity?.UserId;

            var booking = await _unitOfWork.Bookings.GetAll()
                .Include(b => b.SubField).ThenInclude(sf => sf.Field)
                .Include(b => b.BookingServices).ThenInclude(bs => bs.FieldService)
                .FirstOrDefaultAsync(b => b.BookingId == bookingId);
            if (booking == null) return null;
            if (!isOwner && (userEntity == null || booking.UserId != userId)) return null;
            if (isOwner)
            {
                var owner = await _unitOfWork.Owners.GetAll()
                    .FirstOrDefaultAsync(o => o.AccountId == accountId);
                if (owner == null || booking.SubField.Field.OwnerId != owner.OwnerId) return null;
            }

            return booking.BookingServices.Select(bs => new BookingServiceDto
            {
                FieldServiceId = bs.FieldServiceId,
                ServiceName = bs.FieldService?.ServiceName ?? "Unknown",
                Price = bs.Price,
                Quantity = bs.Quantity
            }).ToList();
        }

        public async Task<BookingPreviewDto> PreviewBookingAsync(CreateBookingDto createBookingDto)
        {
            var subField = await _unitOfWork.SubFields.GetAll()
                .Include(sf => sf.Field)
                .FirstOrDefaultAsync(sf => sf.SubFieldId == createBookingDto.SubFieldId);
            if (subField == null) throw new Exception("Sân nhỏ không tồn tại.");

            var startTime = TimeSpan.Parse(createBookingDto.StartTime);
            var endTime = TimeSpan.Parse(createBookingDto.EndTime);
            var duration = (endTime - startTime).TotalHours;
            decimal totalPrice = (decimal)duration * subField.PricePerHour;

            var services = new List<BookingServiceDto>();
            if (createBookingDto.ServiceIds != null && createBookingDto.ServiceIds.Any())
            {
                var fieldServices = await _unitOfWork.FieldServices.FindAsync(fs =>
                    createBookingDto.ServiceIds.Contains(fs.FieldServiceId));
                _logger.LogInformation("Found {Count} field services for SubFieldId {SubFieldId}", fieldServices.Count(), createBookingDto.SubFieldId);
                foreach (var service in fieldServices)
                {
                    totalPrice += service.Price;
                    services.Add(new BookingServiceDto
                    {
                        FieldServiceId = service.FieldServiceId,
                        ServiceName = service.ServiceName,
                        Price = service.Price,
                        Quantity = 1
                    });
                }
            }

            return new BookingPreviewDto
            {
                SubFieldId = subField.SubFieldId,
                FieldName = subField.Field.FieldName,
                SubFieldName = subField.SubFieldName,
                BookingDate = createBookingDto.BookingDate,
                StartTime = createBookingDto.StartTime,
                EndTime = createBookingDto.EndTime,
                TotalPrice = totalPrice,
                Services = services
            };
        }

        private IQueryable<Booking> ApplySorting(IQueryable<Booking> query, string? sort)
        {
            if (string.IsNullOrEmpty(sort)) return query.OrderByDescending(b => b.BookingDate);
            var parts = sort.Split(':');
            var field = parts[0];
            var direction = parts.Length > 1 && parts[1].ToLower() == "desc" ? "desc" : "asc";

            return field.ToLower() switch
            {
                "bookingdate" => direction == "desc" ? query.OrderByDescending(b => b.BookingDate) : query.OrderBy(b => b.BookingDate),
                "createdat" => direction == "desc" ? query.OrderByDescending(b => b.CreatedAt) : query.OrderBy(b => b.CreatedAt),
                _ => query.OrderByDescending(b => b.BookingDate)
            };
        }

        private async Task<BookingDto> MapToBookingDto(Booking booking)
        {
            var subField = await _unitOfWork.SubFields.GetAll()
                .Include(sf => sf.Field)
                .FirstOrDefaultAsync(sf => sf.SubFieldId == booking.SubFieldId);

            var services = booking.BookingServices != null
                ? booking.BookingServices.Select(bs => new BookingServiceDto
                {
                    FieldServiceId = bs.FieldServiceId,
                    ServiceName = bs.FieldService?.ServiceName ?? "Unknown",
                    Price = bs.Price,
                    Quantity = bs.Quantity
                }).ToList()
                : new List<BookingServiceDto>();

            return new BookingDto
            {
                BookingId = booking.BookingId,
                SubFieldId = booking.SubFieldId,
                FieldName = subField?.Field.FieldName,
                SubFieldName = subField?.SubFieldName,
                BookingDate = booking.BookingDate,
                StartTime = booking.StartTime.ToString(@"hh\:mm"),
                EndTime = booking.EndTime.ToString(@"hh\:mm"),
                TotalPrice = booking.TotalPrice,
                Status = booking.Status,
                PaymentStatus = booking.PaymentStatus,
                Services = services,
                CreatedAt = booking.CreatedAt,
                UpdatedAt = booking.UpdatedAt
            };
        }
    }
}
using api.Interfaces;
using CloudinaryDotNet;
using CloudinaryDotNet.Actions;
using Microsoft.Extensions.Configuration;
using System.Threading.Tasks;

namespace api.Services
{
    public class CloudinaryService : ICloudinaryService
    {
        private readonly Cloudinary _cloudinary;

        public CloudinaryService(IConfiguration configuration)
        {
            var cloudinarySettings = configuration.GetSection("CloudinarySettings");
            var account = new Account(
                cloudinarySettings["CloudName"],
                cloudinarySettings["ApiKey"],
                cloudinarySettings["ApiSecret"]
            );
            _cloudinary = new Cloudinary(account);
        }

        // Upload hình ảnh từ IFormFile
        public async Task<string> UploadImageAsync(IFormFile file)
        {
            if (file == null || file.Length == 0)
                throw new ArgumentException("File is empty or null.");

            var uploadParams = new ImageUploadParams
            {
                File = new FileDescription(file.FileName, file.OpenReadStream()),
                Transformation = new Transformation().Width(800).Height(800).Crop("limit") // Tùy chỉnh kích thước
            };

            var uploadResult = await _cloudinary.UploadAsync(uploadParams);
            return uploadResult.SecureUrl.ToString(); // Trả về URL an toàn
        }

        // Xóa hình ảnh theo publicId
        public async Task<bool> DeleteImageAsync(string publicId)
        {
            var deletionParams = new DeletionParams(publicId);
            var result = await _cloudinary.DestroyAsync(deletionParams);
            return result.Result == "ok";
        }
    }
}
using Microsoft.EntityFrameworkCore;
using api.Interfaces;
using api.Dtos.Field;
using api.Dtos;
using api.Models;
using System.Security.Claims;
using System.Linq;
using api.Data;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using api.Exceptions;

namespace api.Services
{
    public class FieldService : IFieldService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IConfiguration _configuration;
        private readonly ILogger<FieldService> _logger;
        private readonly CloudinaryService _cloudinaryService;
        private readonly IGeocodingService _geocodingService;

        public FieldService(
            IUnitOfWork unitOfWork,
            IConfiguration configuration,
            ILogger<FieldService> logger,
            CloudinaryService cloudinaryService,
            IGeocodingService geocodingService)
        {
            _unitOfWork = unitOfWork;
            _configuration = configuration;
            _logger = logger;
            _cloudinaryService = cloudinaryService;
            _geocodingService = geocodingService;
        }

        public async Task<PaginatedResponse<FieldDto>> GetFieldsAsync(FieldFilterDto filter)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices) // Đổi từ Services
                .Include(f => f.FieldDescriptions)
                .AsQueryable();

            if (!string.IsNullOrEmpty(filter.Status))
                query = query.Where(f => f.Status == filter.Status);

            if (filter.SportId.HasValue)
                query = query.Where(f => f.SportId == filter.SportId.Value);

            if (!string.IsNullOrEmpty(filter.Location))
                query = query.Where(f => f.Address.Contains(filter.Location));

            if (filter.MinPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour >= filter.MinPrice.Value));

            if (filter.MaxPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour <= filter.MaxPrice.Value));

            if (!string.IsNullOrEmpty(filter.Sort))
            {
                var sortParts = filter.Sort.Split(':');
                if (sortParts.Length == 2)
                {
                    var sortField = sortParts[0].ToLower();
                    var sortOrder = sortParts[1].ToLower();
                    query = sortField switch
                    {
                        "fieldname" => sortOrder == "asc" ? query.OrderBy(f => f.FieldName) : query.OrderByDescending(f => f.FieldName),
                        "location" => sortOrder == "asc" ? query.OrderBy(f => f.Address) : query.OrderByDescending(f => f.Address),
                        "rating" => sortOrder == "asc" ? query.OrderBy(f => f.Reviews.Average(r => r.Rating)) : query.OrderByDescending(f => f.Reviews.Average(r => r.Rating)),
                        "price" => sortOrder == "asc" ? query.OrderBy(f => f.SubFields.Min(sf => sf.PricePerHour)) : query.OrderByDescending(f => f.SubFields.Min(sf => sf.PricePerHour)),
                        _ => query.OrderBy(f => f.FieldName)
                    };
                }
            }
            else
            {
                query = query.OrderBy(f => f.FieldName);
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((filter.Page - 1) * filter.PageSize)
                .Take(filter.PageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = filter.Page,
                PageSize = filter.PageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<FieldDto> GetFieldByIdAsync(int id)
        {
            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .FirstOrDefaultAsync(f => f.FieldId == id);

            return field != null ? MapToFieldDto(field) : null;
        }

        public async Task<FieldDto> CreateFieldAsync(ClaimsPrincipal user, CreateFieldDto createFieldDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (owner == null)
                throw new ResourceNotFoundException($"No Owner found for AccountId {accountId}");

            var normalizedAddress = NormalizeAddress(createFieldDto.Address);
            decimal latitude = 0m; // Tọa độ mặc định nếu thất bại
            decimal longitude = 0m;
            try
            {
                (latitude, longitude) = await _geocodingService.GetCoordinatesFromAddressAsync(normalizedAddress);
                if (Math.Abs(latitude) > 90 || Math.Abs(longitude) > 180)
                    throw new AppException("Tọa độ không hợp lệ từ dịch vụ địa chỉ");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Geocoding failed for address: {Address}. Using default coordinates (0,0)", normalizedAddress);
                latitude = 0m; // Fallback tọa độ
                longitude = 0m;
                // Không ném exception để tiếp tục tạo field
            }

            var field = new Field
            {
                FieldName = createFieldDto.FieldName,
                Address = createFieldDto.Address,
                Phone = createFieldDto.Phone,
                OpenHours = createFieldDto.OpenHours,
                Status = createFieldDto.Status,
                SportId = createFieldDto.SportId,
                Latitude = latitude,
                Longitude = longitude,
                OwnerId = owner.OwnerId,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            await _unitOfWork.Fields.AddAsync(field);
            await _unitOfWork.SaveChangesAsync();

            // Logic thêm description, amenities, services, subfields giữ nguyên
            if (!string.IsNullOrEmpty(createFieldDto.Description))
            {
                field.FieldDescriptions.Add(new FieldDescription
                {
                    FieldId = field.FieldId,
                    Description = createFieldDto.Description
                });
            }

            if (createFieldDto.Amenities != null && createFieldDto.Amenities.Any())
            {
                foreach (var amenity in createFieldDto.Amenities)
                {
                    field.FieldAmenities.Add(new FieldAmenity
                    {
                        FieldId = field.FieldId,
                        AmenityName = amenity.Name,
                        Description = amenity.Description ?? string.Empty
                    });
                }
            }

            if (createFieldDto.Services != null && createFieldDto.Services.Any())
            {
                foreach (var service in createFieldDto.Services)
                {
                    field.FieldServices.Add(new Models.FieldService
                    {
                        FieldId = field.FieldId,
                        ServiceName = service.ServiceName,
                        Price = service.Price,
                        Description = service.Description ?? string.Empty
                    });
                }
            }

            if (createFieldDto.SubFields != null && createFieldDto.SubFields.Any())
            {
                foreach (var subFieldDto in createFieldDto.SubFields)
                {
                    field.SubFields.Add(new SubField
                    {
                        FieldId = field.FieldId,
                        SubFieldName = subFieldDto.SubFieldName,
                        Size = subFieldDto.Size,
                        PricePerHour = subFieldDto.PricePerHour,
                        Status = "Active"
                    });
                }
            }

            await _unitOfWork.SaveChangesAsync();
            return await GetFieldByIdAsync(field.FieldId);
        }

        public async Task<FieldDto> UpdateFieldAsync(ClaimsPrincipal user, int id, UpdateFieldDto updateFieldDto)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.SubFields)
                .Include(f => f.FieldDescriptions)
                .FirstOrDefaultAsync(f => f.FieldId == id);

            if (field == null)
                throw new ResourceNotFoundException($"Field with ID {id} not found");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (field.OwnerId != owner?.OwnerId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            var normalizedAddress = NormalizeAddress(updateFieldDto.Address);
            decimal latitude = 0m; // Tọa độ mặc định nếu thất bại
            decimal longitude = 0m;
            try
            {
                (latitude, longitude) = await _geocodingService.GetCoordinatesFromAddressAsync(normalizedAddress);
                if (Math.Abs(latitude) > 90 || Math.Abs(longitude) > 180)
                    throw new AppException("Tọa độ không hợp lệ từ dịch vụ địa chỉ");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Geocoding failed for address: {Address}. Using default coordinates (0,0)", normalizedAddress);
                latitude = 0m; // Fallback tọa độ
                longitude = 0m;
                // Không ném exception để tiếp tục tạo field
            }

            field.FieldName = updateFieldDto.FieldName;
            field.Address = updateFieldDto.Address;
            field.Phone = updateFieldDto.Phone;
            field.OpenHours = updateFieldDto.OpenHours;
            field.Status = updateFieldDto.Status;
            field.Latitude = latitude;
            field.Longitude = longitude;
            field.UpdatedAt = DateTime.UtcNow;

            // Logic cập nhật description, amenities, services, subfields giữ nguyên
            field.FieldDescriptions.Clear();
            if (!string.IsNullOrEmpty(updateFieldDto.Description))
            {
                field.FieldDescriptions.Add(new FieldDescription
                {
                    FieldId = field.FieldId,
                    Description = updateFieldDto.Description
                });
            }

            field.FieldAmenities.Clear();
            if (updateFieldDto.Amenities != null && updateFieldDto.Amenities.Any())
            {
                foreach (var amenity in updateFieldDto.Amenities)
                {
                    field.FieldAmenities.Add(new FieldAmenity
                    {
                        FieldId = field.FieldId,
                        AmenityName = amenity.Name,
                        Description = amenity.Description ?? string.Empty
                    });
                }
            }

            field.FieldServices.Clear();
            if (updateFieldDto.Services != null && updateFieldDto.Services.Any())
            {
                foreach (var service in updateFieldDto.Services)
                {
                    field.FieldServices.Add(new Models.FieldService
                    {
                        FieldId = field.FieldId,
                        ServiceName = service.ServiceName,
                        Price = service.Price,
                        Description = service.Description ?? string.Empty
                    });
                }
            }

            field.SubFields.Clear();
            if (updateFieldDto.SubFields != null && updateFieldDto.SubFields.Any())
            {
                foreach (var subFieldDto in updateFieldDto.SubFields)
                {
                    field.SubFields.Add(new SubField
                    {
                        FieldId = field.FieldId,
                        SubFieldName = subFieldDto.SubFieldName,
                        Size = subFieldDto.Size,
                        PricePerHour = subFieldDto.PricePerHour,
                        Status = subFieldDto.Status ?? "Active"
                    });
                }
            }

            await _unitOfWork.SaveChangesAsync();
            return await GetFieldByIdAsync(id);
        }

        private string NormalizeAddress(string address)
        {
            if (string.IsNullOrWhiteSpace(address))
            {
                _logger.LogError("Address is null or empty");
                throw new ArgumentException("Địa chỉ không được để trống");
            }

            // Loại bỏ khoảng trắng thừa
            address = address.Trim();

            // Chuẩn hóa dấu phẩy
            address = address.Replace(" ,", ",").Replace(", ", ",");

            // Loại bỏ "Việt Nam" hoặc "Vietnam" ở cuối nếu có
            address = address.TrimEnd(new[] { ',', ' ' });
            if (address.EndsWith(",Việt Nam", StringComparison.OrdinalIgnoreCase) ||
                address.EndsWith(",Vietnam", StringComparison.OrdinalIgnoreCase))
            {
                address = address.Substring(0, address.LastIndexOf(','));
            }

            // Thêm quốc gia nếu chưa có
            if (!address.EndsWith(", Việt Nam", StringComparison.OrdinalIgnoreCase) &&
                !address.EndsWith(", Vietnam", StringComparison.OrdinalIgnoreCase))
            {
                address = $"{address}, Việt Nam";
            }

            _logger.LogDebug("Normalized address from '{Original}' to '{Normalized}'", address, address);
            return address;
        }

        public async Task DeleteFieldAsync(ClaimsPrincipal user, int id)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.Bookings)
                .FirstOrDefaultAsync(f => f.FieldId == id);
            if (field == null)
                return;

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (field.OwnerId != owner.OwnerId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            var hasBookings = field.SubFields.Any(sf => sf.Bookings.Any(b => b.Status != "Canceled" && b.Status != "Completed"));
            if (hasBookings)
                throw new InvalidOperationException("Cannot delete field with active bookings");

            _unitOfWork.Fields.Delete(field);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<string> UploadFieldImageAsync(ClaimsPrincipal user, int fieldId, string imageBase64)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var field = await _unitOfWork.Fields.GetByIdAsync(fieldId);
            if (field == null)
                throw new ArgumentException("Field not found");

            if (field.OwnerId != accountId)
                throw new UnauthorizedAccessException("User is not the owner of this field");

            if (string.IsNullOrEmpty(imageBase64))
                throw new ArgumentException("Image data is empty or null");

            byte[] imageBytes = Convert.FromBase64String(imageBase64);
            using var stream = new MemoryStream(imageBytes);
            var file = new FormFile(stream, 0, imageBytes.Length, "fieldImage", "image.jpg")
            {
                Headers = new HeaderDictionary(),
                ContentType = "image/jpeg"
            };

            var imageUrl = await _cloudinaryService.UploadImageAsync(file);
            if (string.IsNullOrEmpty(imageUrl))
                throw new Exception("Failed to upload image to Cloudinary");

            field.FieldImages.Add(new FieldImage
            {
                FieldId = fieldId,
                ImageUrl = imageUrl
            });

            await _unitOfWork.SaveChangesAsync();
            return imageUrl;
        }

        public async Task<PaginatedResponse<FieldDto>> GetOwnerFieldsAsync(
            ClaimsPrincipal user, string status, string sort, int page, int pageSize)
        {
            var accountId = int.Parse(user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "0");
            if (accountId == 0)
                throw new UnauthorizedAccessException("User not authenticated");

            var owner = await _unitOfWork.Owners.GetAll()
                .FirstOrDefaultAsync(o => o.AccountId == accountId);
            if (owner == null)
                throw new InvalidOperationException($"No Owner found for AccountId {accountId}");

            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .Where(f => f.OwnerId == owner.OwnerId)
                .AsQueryable();

            if (!string.IsNullOrEmpty(status))
                query = query.Where(f => f.Status == status);

            query = sort?.ToLower() switch
            {
                "name" => query.OrderBy(f => f.FieldName),
                "status" => query.OrderBy(f => f.Status),
                "created" => query.OrderByDescending(f => f.CreatedAt),
                _ => query.OrderByDescending(f => f.UpdatedAt)
            };

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<FieldAvailabilityDto> GetFieldAvailabilityAsync(int fieldId, DateTime date)
        {
            var field = await _unitOfWork.Fields.GetAll()
                .Include(f => f.FieldServices)
                .Include(f => f.SubFields)
                    .ThenInclude(sf => sf.Bookings)
                .FirstOrDefaultAsync(f => f.FieldId == fieldId);

            if (field == null)
                return null;

            var openHours = field.OpenHours.Split('-');
            var startTime = TimeSpan.Parse(openHours[0]);
            var endTime = TimeSpan.Parse(openHours[1]);

            var subFields = new List<SubFieldAvailabilityDto>();
            foreach (var subField in field.SubFields)
            {
                var slots = new List<TimeSlotDto>();
                var currentTime = startTime;

                while (currentTime < endTime)
                {
                    var slotEndTime = currentTime.Add(TimeSpan.FromHours(1));
                    var isBooked = subField.Bookings.Any(b =>
                        b.BookingDate.Date == date.Date &&
                        b.StartTime <= currentTime &&
                        b.EndTime > currentTime);

                    slots.Add(new TimeSlotDto
                    {
                        StartTime = currentTime.ToString(@"hh\:mm"), // Chỉ lấy giờ
                        EndTime = slotEndTime.ToString(@"hh\:mm"),   // Chỉ lấy giờ
                        Status = isBooked ? "Booked" : "Available"
                    });

                    currentTime = slotEndTime;
                }

                subFields.Add(new SubFieldAvailabilityDto
                {
                    SubFieldId = subField.SubFieldId,
                    Name = subField.SubFieldName,
                    PricePerHour = subField.PricePerHour,
                    Slots = slots
                });
            }

            return new FieldAvailabilityDto
            {
                FieldId = field.FieldId,
                FieldName = field.FieldName,
                Date = date.ToString("yyyy-MM-dd"),
                OpenHours = field.OpenHours,
                Services = field.FieldServices.Select(s => new FieldServiceAvailabilityDto
                {
                    Name = s.ServiceName,
                    Price = s.Price
                }).ToList(),
                SubFields = subFields
            };
        }

        private static FieldDto MapToFieldDto(Field field)
        {
            return new FieldDto
            {
                FieldId = field.FieldId,
                FieldName = field.FieldName,
                SportId = field.SportId,
                SportName = field.Sport?.SportName,
                Address = field.Address,
                Phone = field.Phone,
                OpenHours = field.OpenHours,
                Latitude = field.Latitude,
                Longitude = field.Longitude,
                Status = field.Status,
                Images = field.FieldImages.Select(i => i.ImageUrl).ToList(),
                Amenities = field.FieldAmenities.Select(a => new FieldAmenityDto
                {
                    AmenityName = a.AmenityName,
                    Description = a.Description
                }).ToList(),
                Services = field.FieldServices.Select(s => new FieldServiceDto
                {
                    Name = s.ServiceName,
                    Price = s.Price,
                    Description = s.Description
                }).ToList(),
                SubFields = field.SubFields.Select(sf => new SubFieldDto
                {
                    SubFieldId = sf.SubFieldId,
                    Name = sf.SubFieldName,
                    Size = sf.Size,
                    PricePerHour = sf.PricePerHour,
                    Status = sf.Status
                }).ToList()
            };
        }

        public async Task<PaginatedResponse<FieldReviewDto>> GetFieldReviewsAsync(
            int fieldId, int? rating, string sort, int page, int pageSize)
        {
            var query = _unitOfWork.Reviews.GetAll()
                .Include(r => r.User)
                .Where(r => r.FieldId == fieldId)
                .AsQueryable();

            if (rating.HasValue)
                query = query.Where(r => r.Rating == rating.Value);

            if (!string.IsNullOrEmpty(sort))
            {
                var sortParts = sort.Split(':');
                if (sortParts.Length == 2)
                {
                    var sortField = sortParts[0].ToLower();
                    var sortOrder = sortParts[1].ToLower();
                    query = sortField switch
                    {
                        "createdat" => sortOrder == "asc" ? query.OrderBy(r => r.CreatedAt) : query.OrderByDescending(r => r.CreatedAt),
                        "rating" => sortOrder == "asc" ? query.OrderBy(r => r.Rating) : query.OrderByDescending(r => r.Rating),
                        _ => query.OrderByDescending(r => r.CreatedAt)
                    };
                }
            }
            else
            {
                query = query.OrderByDescending(r => r.CreatedAt);
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldReviewDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(r => new FieldReviewDto
                {
                    ReviewId = r.ReviewId,
                    UserName = r.User?.FullName,
                    Rating = r.Rating,
                    Comment = r.Comment,
                    CreatedAt = r.CreatedAt
                }).ToList()
            };
        }

        public async Task<PaginatedResponse<FieldDto>> GetNearbyFieldsAsync(
            decimal latitude, decimal longitude, decimal radius, string sort, int page, int pageSize)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .Where(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude) <= radius)
                .AsQueryable();

            query = sort?.ToLower() switch
            {
                "distance" => query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude)),
                "rating" => query.OrderByDescending(f => f.Reviews.Average(r => r.Rating)),
                "price" => query.OrderBy(f => f.SubFields.Min(sf => sf.PricePerHour)),
                _ => query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude, longitude))
            };

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        public async Task<PaginatedResponse<FieldDto>> SearchFieldsAsync(FieldSearchDto search)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .AsQueryable();

            if (!string.IsNullOrEmpty(search.SearchTerm))
            {
                var searchTermLower = search.SearchTerm.ToLower();
                query = query.Where(f =>
                    f.FieldName.ToLower().Contains(searchTermLower) ||
                    f.FieldDescriptions.Any(d => d.Description != null && d.Description.ToLower().Contains(searchTermLower)) ||
                    f.Address.ToLower().Contains(searchTermLower));
            }

            if (search.SportId.HasValue)
                query = query.Where(f => f.SportId == search.SportId.Value);

            if (search.MinPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour >= search.MinPrice.Value));

            if (search.MaxPrice.HasValue)
                query = query.Where(f => f.SubFields.Any(sf => sf.PricePerHour <= search.MaxPrice.Value));

            if (search.Latitude.HasValue && search.Longitude.HasValue && search.Radius.HasValue)
            {
                query = query.Where(f =>
                    CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value) <= search.Radius.Value);
            }
            else if (!string.IsNullOrEmpty(search.Location))
            {
                var locationLower = search.Location.ToLower();
                query = query.Where(f => f.Address.ToLower().Contains(locationLower));
            }

            if (search.Time.HasValue)
            {
                var date = search.Time.Value.Date;
                var time = search.Time.Value.TimeOfDay;
                query = query.Where(f => f.SubFields.Any(sf =>
                    !sf.Bookings.Any(b => b.BookingDate.Date == date &&
                                         b.StartTime <= time && b.EndTime >= time)));
            }

            if (!string.IsNullOrEmpty(search.Sort))
            {
                switch (search.Sort.ToLower())
                {
                    case "rating:asc":
                        query = query.OrderBy(f => f.Reviews.Any() ? f.Reviews.Average(r => r.Rating) : 0);
                        break;
                    case "rating:desc":
                        query = query.OrderByDescending(f => f.Reviews.Any() ? f.Reviews.Average(r => r.Rating) : 0);
                        break;
                    case "price:asc":
                        query = query.OrderBy(f => f.SubFields.Any() ? f.SubFields.Min(sf => sf.PricePerHour) : 0);
                        break;
                    case "price:desc":
                        query = query.OrderByDescending(f => f.SubFields.Any() ? f.SubFields.Max(sf => sf.PricePerHour) : decimal.MaxValue);
                        break;
                    case "distance:asc":
                        if (search.Latitude.HasValue && search.Longitude.HasValue)
                            query = query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value));
                        break;
                    case "distance:desc":
                        if (search.Latitude.HasValue && search.Longitude.HasValue)
                            query = query.OrderByDescending(f => CalculateDistance(f.Latitude, f.Longitude, search.Latitude.Value, search.Longitude.Value));
                        break;
                    default:
                        query = query.OrderBy(f => f.FieldName);
                        break;
                }
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((search.Page - 1) * search.PageSize)
                .Take(search.PageSize)
                .Select(f => MapToFieldDto(f))
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = search.Page,
                PageSize = search.PageSize,
                Items = items
            };
        }

        public async Task ReportFieldAsync(int fieldId, FieldReportDto reportDto)
        {
            var field = await _unitOfWork.Fields.GetByIdAsync(fieldId);
            if (field == null)
                throw new ArgumentException("Field not found");

            _logger.LogInformation("Field {FieldId} reported: {Reason}", fieldId, reportDto.Reason);
            // TODO: Thêm logic lưu báo cáo vào DB nếu cần
        }

        public async Task<PaginatedResponse<FieldDto>> GetSuggestedFieldsAsync(
            decimal? latitude, decimal? longitude, int page, int pageSize)
        {
            var query = _unitOfWork.Fields.GetAll()
                .Include(f => f.Sport)
                .Include(f => f.FieldImages)
                .Include(f => f.SubFields)
                .Include(f => f.FieldAmenities)
                .Include(f => f.FieldServices)
                .Include(f => f.FieldDescriptions)
                .Where(f => f.Status == "Active")
                .AsQueryable();

            if (latitude.HasValue && longitude.HasValue)
            {
                query = query.OrderBy(f => CalculateDistance(f.Latitude, f.Longitude, latitude.Value, longitude.Value));
            }
            else
            {
                query = query.OrderByDescending(f => f.Reviews.Average(r => r.Rating));
            }

            var totalItems = await query.CountAsync();
            var items = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedResponse<FieldDto>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items.Select(f => MapToFieldDto(f))
            };
        }

        private decimal CalculateDistance(decimal lat1, decimal lon1, decimal lat2, decimal lon2)
        {
            var R = 6371m; // Bán kính trái đất (km)
            var dLat = ToRad(lat2 - lat1);
            var dLon = ToRad(lon2 - lon1);
            var a = (decimal)Math.Sin((double)(dLat / 2)) * (decimal)Math.Sin((double)(dLat / 2)) +
                    (decimal)Math.Cos((double)ToRad(lat1)) * (decimal)Math.Cos((double)ToRad(lat2)) *
                    (decimal)Math.Sin((double)(dLon / 2)) * (decimal)Math.Sin((double)(dLon / 2));
            var c = 2 * (decimal)Math.Atan2(Math.Sqrt((double)a), Math.Sqrt(1 - (double)a));
            return R * c;
        }

        private decimal ToRad(decimal value)
        {
            return value * (decimal)Math.PI / 180;
        }
    }
}
using System;
using System.Linq;
using System.Security.Claims;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using api.Data;
using api.Dtos;
using api.Dtos.User;
using api.Interfaces;
using api.Models;
using Microsoft.EntityFrameworkCore;

namespace api.Services
{
    public class UserService : IUserService
    {
        private readonly IUnitOfWork _unitOfWork;

        public UserService(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }

        private async Task<User> GetCurrentUserAsync(ClaimsPrincipal user)
        {
            var accountIdClaim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(accountIdClaim) || !int.TryParse(accountIdClaim, out int accountId))
            {
                throw new Exception("Token người dùng không hợp lệ.");
            }

            var dbUser = await _unitOfWork.Users.GetAll()
                .Include(u => u.Account)
                .FirstOrDefaultAsync(u => u.AccountId == accountId);
            if (dbUser == null)
            {
                throw new Exception("Không tìm thấy người dùng.");
            }

            return dbUser;
        }

        private async Task<Account> GetCurrentAccountAsync(ClaimsPrincipal user)
        {
            var accountIdClaim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(accountIdClaim) || !int.TryParse(accountIdClaim, out int accountId))
            {
                throw new Exception("Token người dùng không hợp lệ.");
            }

            var account = await _unitOfWork.Accounts.GetAll()
                .FirstOrDefaultAsync(a => a.AccountId == accountId);
            if (account == null)
            {
                throw new Exception("Không tìm thấy tài khoản.");
            }

            return account;
        }

        public async Task<UserProfileResponseDto> GetUserProfileAsync(ClaimsPrincipal user)
        {
            var account = await GetCurrentAccountAsync(user);
            var role = account.Role;

            if (role == "User")
            {
                var dbUser = await _unitOfWork.Users.GetAll()
                    .Include(u => u.Account)
                    .FirstOrDefaultAsync(u => u.AccountId == account.AccountId);
                if (dbUser == null)
                {
                    throw new Exception("Không tìm thấy thông tin người dùng.");
                }

                return new UserProfileResponseDto
                {
                    Email = dbUser.Email,
                    Role = account.Role,
                    FullName = dbUser.FullName,
                    Phone = dbUser.Phone,
                    Gender = dbUser.Gender,
                    DateOfBirth = dbUser.DateOfBirth?.ToString("yyyy-MM-dd"),
                    // AvatarUrl = dbUser.AvatarUrl
                };
            }
            else if (role == "Owner")
            {
                var dbOwner = await _unitOfWork.Owners.GetAll()
                    .Include(o => o.Account)
                    .FirstOrDefaultAsync(o => o.AccountId == account.AccountId);
                if (dbOwner == null)
                {
                    throw new Exception("Không tìm thấy thông tin chủ sân.");
                }

                return new UserProfileResponseDto
                {
                    Email = dbOwner.Email,
                    Role = account.Role,
                    FullName = dbOwner.FullName,
                    Phone = dbOwner.Phone,
                    Gender = null, // Owner không có trường Gender
                    DateOfBirth = null, // Owner không có trường DateOfBirth
                    // AvatarUrl = null // Owner không có trường AvatarUrl 
                };
            }
            else
            {
                throw new Exception("Vai trò không được hỗ trợ.");
            }
        }

        public async Task UpdateUserProfileAsync(ClaimsPrincipal user, UpdateProfileDto updateProfileDto)
        {
            var account = await GetCurrentAccountAsync(user);
            var role = account.Role;

            // Kiểm tra định dạng số điện thoại
            if (!string.IsNullOrEmpty(updateProfileDto.Phone) && !Regex.IsMatch(updateProfileDto.Phone, @"^[0-9]{10}$"))
            {
                throw new Exception("Số điện thoại không hợp lệ, phải là 10 chữ số.");
            }

            if (role == "User")
            {
                var dbUser = await _unitOfWork.Users.GetAll()
                    .FirstOrDefaultAsync(u => u.AccountId == account.AccountId);
                if (dbUser == null)
                {
                    throw new Exception("Không tìm thấy người dùng.");
                }

                // Cập nhật các trường bắt buộc
                dbUser.FullName = updateProfileDto.FullName;
                dbUser.Phone = updateProfileDto.Phone;
                dbUser.Gender = updateProfileDto.Gender;
                dbUser.DateOfBirth = updateProfileDto.DateOfBirth;

                _unitOfWork.Users.Update(dbUser);
            }
            else if (role == "Owner")
            {
                var dbOwner = await _unitOfWork.Owners.GetAll()
                    .FirstOrDefaultAsync(o => o.AccountId == account.AccountId);
                if (dbOwner == null)
                {
                    throw new Exception("Không tìm thấy chủ sân.");
                }

                dbOwner.FullName = updateProfileDto.FullName;
                dbOwner.Phone = updateProfileDto.Phone;
                dbOwner.UpdatedAt = DateTime.UtcNow; // Cập nhật thời gian chỉnh sửa

                _unitOfWork.Owners.Update(dbOwner);
            }
            else
            {
                throw new Exception("Vai trò không được hỗ trợ.");
            }

            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<PaginatedResponse<Booking>> GetUserBookingsAsync(ClaimsPrincipal user, string status, DateTime? date, string sort, int page, int pageSize)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User
            var query = _unitOfWork.Bookings.GetAll()
                .Include(b => b.SubField)
                .Where(b => b.UserId == dbUser.UserId)
                .AsQueryable();

            if (!string.IsNullOrEmpty(status))
            {
                query = query.Where(b => b.Status == status);
            }

            if (date.HasValue)
            {
                query = query.Where(b => b.BookingDate.Date == date.Value.Date);
            }

            if (!string.IsNullOrEmpty(sort))
            {
                var sortParts = sort.Split(':');
                var sortField = sortParts[0];
                var sortDirection = sortParts.Length > 1 ? sortParts[1].ToLower() : "asc";

                query = sortField switch
                {
                    "BookingDate" => sortDirection == "desc" ? query.OrderByDescending(b => b.BookingDate) : query.OrderBy(b => b.BookingDate),
                    "CreatedAt" => sortDirection == "desc" ? query.OrderByDescending(b => b.CreatedAt) : query.OrderBy(b => b.CreatedAt), // Sửa lỗi typo
                    _ => query.OrderBy(b => b.BookingDate)
                };
            }
            else
            {
                query = query.OrderBy(b => b.BookingDate);
            }

            var totalItems = await query.CountAsync();
            var items = await query.Skip((page - 1) * pageSize).Take(pageSize).ToListAsync();

            return new PaginatedResponse<Booking>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items
            };
        }

        public async Task DeactivateUserAsync(ClaimsPrincipal user)
        {
            var account = await GetCurrentAccountAsync(user);
            account.IsActive = false;
            _unitOfWork.Accounts.Update(account);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task<PaginatedResponse<FavoriteField>> GetFavoriteFieldsAsync(ClaimsPrincipal user, string sort, int page, int pageSize)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User
            var query = _unitOfWork.FavoriteFields.GetAll()
                .Include(ff => ff.Field)
                    .ThenInclude(f => f.Sport)
                .Where(ff => ff.UserId == dbUser.UserId)
                .AsQueryable();

            if (!string.IsNullOrEmpty(sort))
            {
                var sortParts = sort.Split(':');
                var sortField = sortParts[0];
                var sortDirection = sortParts.Length > 1 ? sortParts[1].ToLower() : "asc";

                query = sortField switch
                {
                    "AddedDate" => sortDirection == "desc" ? query.OrderByDescending(ff => ff.AddedDate) : query.OrderBy(ff => ff.AddedDate),
                    "FieldName" => sortDirection == "desc" ? query.OrderByDescending(ff => ff.Field.FieldName) : query.OrderBy(ff => ff.Field.FieldName),
                    _ => query.OrderBy(ff => ff.AddedDate)
                };
            }
            else
            {
                query = query.OrderBy(ff => ff.AddedDate);
            }

            var totalItems = await query.CountAsync();
            var items = await query.Skip((page - 1) * pageSize).Take(pageSize).ToListAsync();

            return new PaginatedResponse<FavoriteField>
            {
                TotalItems = totalItems,
                Page = page,
                PageSize = pageSize,
                Items = items
            };
        }

        public async Task AddFavoriteFieldAsync(ClaimsPrincipal user, int fieldId)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User

            var field = await _unitOfWork.Fields.GetAll().FirstOrDefaultAsync(f => f.FieldId == fieldId);
            if (field == null)
            {
                throw new Exception("Field does not exist.");
            }

            var existingFavorite = await _unitOfWork.FavoriteFields.GetAll()
                .FirstOrDefaultAsync(f => f.FieldId == fieldId && f.UserId == dbUser.UserId);
            if (existingFavorite != null)
            {
                throw new Exception("Field already in favorites.");
            }

            var favorite = new FavoriteField
            {
                UserId = dbUser.UserId,
                FieldId = fieldId,
                AddedDate = DateTime.UtcNow
            };

            await _unitOfWork.FavoriteFields.AddAsync(favorite);
            await _unitOfWork.SaveChangesAsync();
        }

        public async Task RemoveFavoriteFieldAsync(ClaimsPrincipal user, int fieldId)
        {
            var dbUser = await GetCurrentUserAsync(user); // Chỉ áp dụng cho User
            var favorite = await _unitOfWork.FavoriteFields.GetAll()
                .FirstOrDefaultAsync(ff => ff.UserId == dbUser.UserId && ff.FieldId == fieldId);

            if (favorite == null)
            {
                throw new Exception("Field not found in favorites.");
            }

            _unitOfWork.FavoriteFields.Delete(favorite);
            await _unitOfWork.SaveChangesAsync();
        }
    }
}